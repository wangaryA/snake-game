<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Snake Game</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#00ff88">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Snake">
    <link rel="apple-touch-icon" href="icons/icon-192.svg">

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00ff88;
            --primary-dim: rgba(0, 255, 136, 0.3);
            --secondary: #00d4ff;
            --accent: #ff0055;
            --accent-orange: #ff6600;
            --gold: #ffd700;
            --bg-dark: #0a0a1a;
            --bg-card: rgba(15, 15, 35, 0.8);
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --bg-gradient: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 50%, #0a0a1a 100%);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --canvas-bg: linear-gradient(180deg, #0d0d1a 0%, #0a0a15 100%);
            --grid-color: rgba(255, 255, 255, 0.03);
        }

        /* ===== THEME: Neon Cyberpunk (Default) ===== */
        [data-theme="neon"] {
            --primary: #00ff88;
            --primary-dim: rgba(0, 255, 136, 0.3);
            --secondary: #00d4ff;
            --accent: #ff0055;
            --accent-orange: #ff6600;
            --gold: #ffd700;
            --bg-dark: #0a0a1a;
            --bg-card: rgba(15, 15, 35, 0.8);
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --bg-gradient: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 50%, #0a0a1a 100%);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --canvas-bg: linear-gradient(180deg, #0d0d1a 0%, #0a0a15 100%);
            --grid-color: rgba(255, 255, 255, 0.03);
        }

        /* ===== THEME: Retro Arcade ===== */
        [data-theme="retro"] {
            --primary: #ffcc00;
            --primary-dim: rgba(255, 204, 0, 0.3);
            --secondary: #ff6b35;
            --accent: #e83f6f;
            --accent-orange: #ff9f1c;
            --gold: #ffd700;
            --bg-dark: #1a1a2e;
            --bg-card: rgba(30, 30, 60, 0.9);
            --glass: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 204, 0, 0.2);
            --bg-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --canvas-bg: linear-gradient(180deg, #0f0f23 0%, #1a1a2e 100%);
            --grid-color: rgba(255, 204, 0, 0.05);
        }

        /* ===== THEME: Ocean Blue ===== */
        [data-theme="ocean"] {
            --primary: #00b4d8;
            --primary-dim: rgba(0, 180, 216, 0.3);
            --secondary: #90e0ef;
            --accent: #ff6b6b;
            --accent-orange: #48cae4;
            --gold: #ffd700;
            --bg-dark: #03045e;
            --bg-card: rgba(3, 4, 94, 0.8);
            --glass: rgba(144, 224, 239, 0.05);
            --glass-border: rgba(0, 180, 216, 0.2);
            --bg-gradient: linear-gradient(135deg, #03045e 0%, #023e8a 50%, #0077b6 100%);
            --text-primary: #caf0f8;
            --text-secondary: rgba(202, 240, 248, 0.7);
            --canvas-bg: linear-gradient(180deg, #023e8a 0%, #03045e 100%);
            --grid-color: rgba(0, 180, 216, 0.05);
        }

        /* ===== THEME: Nature/Forest ===== */
        [data-theme="forest"] {
            --primary: #80b918;
            --primary-dim: rgba(128, 185, 24, 0.3);
            --secondary: #55a630;
            --accent: #d00000;
            --accent-orange: #aacc00;
            --gold: #ffd700;
            --bg-dark: #1b2a1b;
            --bg-card: rgba(27, 42, 27, 0.9);
            --glass: rgba(128, 185, 24, 0.05);
            --glass-border: rgba(128, 185, 24, 0.2);
            --bg-gradient: linear-gradient(135deg, #1b2a1b 0%, #2d4a2d 50%, #1b2a1b 100%);
            --text-primary: #e8f5e9;
            --text-secondary: rgba(232, 245, 233, 0.7);
            --canvas-bg: linear-gradient(180deg, #1b2a1b 0%, #2d4a2d 100%);
            --grid-color: rgba(128, 185, 24, 0.05);
        }

        /* ===== THEME: Sunset/Warm ===== */
        [data-theme="sunset"] {
            --primary: #f72585;
            --primary-dim: rgba(247, 37, 133, 0.3);
            --secondary: #7209b7;
            --accent: #4cc9f0;
            --accent-orange: #f77f00;
            --gold: #ffd700;
            --bg-dark: #2b1055;
            --bg-card: rgba(43, 16, 85, 0.9);
            --glass: rgba(247, 37, 133, 0.05);
            --glass-border: rgba(247, 37, 133, 0.2);
            --bg-gradient: linear-gradient(135deg, #2b1055 0%, #4a1a7a 50%, #7b2cbf 100%);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --canvas-bg: linear-gradient(180deg, #3a0ca3 0%, #2b1055 100%);
            --grid-color: rgba(247, 37, 133, 0.05);
        }

        /* ===== PIXEL ART LOADING SCREEN ===== */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        /* CRT Glow Effect */
        .loading-screen::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            height: 280px;
            background: radial-gradient(ellipse, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 40%, transparent 70%);
            pointer-events: none;
            animation: crt-glow 2s ease-in-out infinite;
        }

        @keyframes crt-glow {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        /* Scanlines Overlay */
        .loading-scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 10;
        }

        /* Snake Circle Container */
        .snake-loader {
            position: relative;
            width: 160px;
            height: 160px;
            margin-bottom: 30px;
        }

        /* Snake Circle Track */
        .snake-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            animation: rotate-snake 2s linear infinite;
        }

        @keyframes rotate-snake {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Individual Snake Segments */
        .snake-segment {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 1px solid #000;
            box-sizing: border-box;
            image-rendering: pixelated;
        }

        /* Head Segment - slightly larger with eyes */
        .snake-segment.head {
            width: 14px;
            height: 14px;
            background: #4ade80;
            border: 1px solid #000;
            position: absolute;
        }

        .snake-segment.head::before,
        .snake-segment.head::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 3px;
            background: #000;
            top: 2px;
        }

        .snake-segment.head::before {
            right: 2px;
        }

        .snake-segment.head::after {
            right: 7px;
        }

        /* Body segments with gradient colors */
        .snake-segment.body-1 { background: #22c55e; }
        .snake-segment.body-2 { background: #20b858; }
        .snake-segment.body-3 { background: #1eab52; }
        .snake-segment.body-4 { background: #1c9e4c; }
        .snake-segment.body-5 { background: #1a9146; }
        .snake-segment.body-6 { background: #188440; }
        .snake-segment.body-7 { background: #16773a; }
        .snake-segment.body-8 { background: #156a34; }
        .snake-segment.tail { background: #15803d; }

        /* Position segments in a circle (radius ~45px for 90px diameter) */
        .snake-segment:nth-child(1) { top: 8px; left: 73px; }
        .snake-segment:nth-child(2) { top: 18px; left: 104px; }
        .snake-segment:nth-child(3) { top: 44px; left: 124px; }
        .snake-segment:nth-child(4) { top: 74px; left: 124px; }
        .snake-segment:nth-child(5) { top: 100px; left: 104px; }
        .snake-segment:nth-child(6) { top: 116px; left: 73px; }
        .snake-segment:nth-child(7) { top: 100px; left: 42px; }
        .snake-segment:nth-child(8) { top: 74px; left: 22px; }
        .snake-segment:nth-child(9) { top: 44px; left: 22px; }
        .snake-segment:nth-child(10) { top: 18px; left: 42px; }

        /* Pixel Food in Center */
        .pixel-food {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #ef4444;
            border: 1px solid #000;
            animation: food-pulse 0.8s ease-in-out infinite;
            image-rendering: pixelated;
        }

        .pixel-food::after {
            content: '';
            position: absolute;
            top: -4px;
            left: 2px;
            width: 3px;
            height: 3px;
            background: #22c55e;
            border: 1px solid #000;
        }

        @keyframes food-pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* Pixel Loading Text */
        .loading-text-pixel {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            color: #4ade80;
            letter-spacing: 4px;
            text-transform: uppercase;
            image-rendering: pixelated;
            text-shadow:
                2px 0 0 #000,
                -2px 0 0 #000,
                0 2px 0 #000,
                0 -2px 0 #000,
                0 0 10px rgba(74, 222, 128, 0.5);
        }

        /* Animated Dots */
        .loading-dots {
            display: inline-block;
            width: 24px;
            text-align: left;
        }

        .loading-dots span {
            animation: dot-blink 1.5s infinite;
            opacity: 0;
        }

        .loading-dots span:nth-child(1) { animation-delay: 0s; }
        .loading-dots span:nth-child(2) { animation-delay: 0.3s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.6s; }

        @keyframes dot-blink {
            0%, 20% { opacity: 0; }
            40%, 100% { opacity: 1; }
        }

        /* Retro Border Frame */
        .loading-frame {
            position: relative;
            padding: 40px;
            border: 3px solid #22c55e;
            box-shadow:
                inset 0 0 20px rgba(74, 222, 128, 0.1),
                0 0 30px rgba(74, 222, 128, 0.2);
        }

        .loading-frame::before,
        .loading-frame::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            border: 2px solid #4ade80;
        }

        .loading-frame::before {
            top: -2px;
            left: -2px;
            border-right: none;
            border-bottom: none;
        }

        .loading-frame::after {
            bottom: -2px;
            right: -2px;
            border-left: none;
            border-top: none;
        }

        /* ===== PREMIUM ANIMATED BACKGROUND ===== */
        body {
            background: #05050f;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', sans-serif;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse at 0% 0%, var(--primary-dim) 0%, transparent 50%),
                radial-gradient(ellipse at 100% 100%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(255, 255, 255, 0.02) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
        }

        /* Cinematic ambient light */
        body::after {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg at 50% 50%,
                transparent 0deg,
                var(--primary-dim) 60deg,
                transparent 120deg,
                transparent 180deg,
                rgba(0, 212, 255, 0.05) 240deg,
                transparent 300deg,
                transparent 360deg);
            animation: ambient-rotate 60s linear infinite;
            pointer-events: none;
            z-index: -2;
            opacity: 0.3;
        }

        @keyframes ambient-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Subtle scan line effect for premium feel */
        .scan-lines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.02) 2px,
                rgba(0, 0, 0, 0.02) 4px
            );
            pointer-events: none;
            z-index: 1;
            opacity: 0.6;
        }

        /* Floating orbs - more subtle */
        .bg-orb {
            position: fixed;
            border-radius: 50%;
            filter: blur(120px);
            pointer-events: none;
            z-index: -1;
            animation: orb-float 30s ease-in-out infinite;
        }

        .bg-orb-1 {
            width: 600px;
            height: 600px;
            background: var(--primary);
            opacity: 0.06;
            top: -200px;
            left: -200px;
        }

        .bg-orb-2 {
            width: 500px;
            height: 500px;
            background: var(--secondary);
            opacity: 0.05;
            bottom: -150px;
            right: -150px;
            animation-delay: -15s;
        }

        .bg-orb-3 {
            width: 300px;
            height: 300px;
            background: var(--accent);
            opacity: 0.04;
            top: 40%;
            left: 60%;
            animation-delay: -8s;
        }

        @keyframes orb-float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(50px, -30px) scale(1.05); }
            50% { transform: translate(-30px, 40px) scale(0.98); }
            75% { transform: translate(40px, 20px) scale(1.02); }
        }

        /* ===== MAIN LAYOUT ===== */
        .main-container {
            display: flex;
            gap: 24px;
            align-items: stretch;
            animation: fade-in-up 0.8s ease-out;
            opacity: 0;
            animation-fill-mode: forwards;
            animation-delay: 2s;
            max-width: 1400px;
            width: 100%;
        }

        @keyframes fade-in-up {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-container {
            text-align: center;
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            min-height: 50px;
            padding: 0 8px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--text-primary);
            letter-spacing: 8px;
            position: relative;
            text-shadow: 0 0 40px var(--primary-dim);
        }

        h1::before {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--glass);
            padding: 8px 16px;
            border-radius: 50px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            animation: slide-in-right 0.5s ease-out;
        }

        @keyframes slide-in-right {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid var(--primary);
            box-shadow: 0 0 15px var(--primary-dim);
            transition: all 0.3s ease;
        }

        .user-avatar:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px var(--primary-dim);
        }

        .user-name {
            color: #fff;
            font-size: 0.95rem;
            font-weight: 600;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .auth-btn {
            background: linear-gradient(135deg, var(--primary), #00cc6a);
            color: var(--bg-dark);
            border: none;
            padding: 12px 24px;
            font-size: 0.9rem;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .auth-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }

        .auth-btn:hover::before {
            left: 100%;
        }

        .auth-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 10px 30px var(--primary-dim), 0 0 60px var(--primary-dim);
        }

        .auth-btn:active {
            transform: translateY(0) scale(0.98);
        }

        .auth-btn.sign-out {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
            padding: 8px 16px;
            font-size: 0.8rem;
        }

        .auth-btn.sign-out:hover {
            background: var(--accent);
            color: #fff;
            box-shadow: 0 10px 30px rgba(255, 0, 85, 0.4);
        }

        .google-icon {
            width: 18px;
            height: 18px;
        }

        /* ===== SCORE BOARD ===== */
        .score-board {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 12px;
            padding: 16px 32px;
            background: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0.01) 100%);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.06);
            backdrop-filter: blur(20px);
        }

        .score, .high-score, .timer {
            font-size: 0.75rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .score span, .high-score span {
            color: var(--primary);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            font-size: 1.5rem;
            text-shadow: 0 0 30px var(--primary-dim);
        }

        .mp-live-scores {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .mp-live-score-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .mp-live-score-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
        }

        .mp-live-score-name {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mp-live-score-value {
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            font-size: 1.1rem;
            color: #fff;
        }

        .mp-live-score-item.me {
            border-color: var(--primary);
            background: rgba(0, 255, 136, 0.1);
        }

        .timer span {
            color: var(--accent-orange);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            font-size: 1.5rem;
        }

        .timer.urgent span {
            color: var(--accent);
            animation: urgent-pulse 0.5s ease infinite;
        }

        @keyframes urgent-pulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 20px var(--accent); }
            50% { opacity: 0.6; text-shadow: 0 0 40px var(--accent); }
        }

        .mode-indicator {
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            margin-bottom: 12px;
            min-height: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .mode-indicator span {
            color: var(--primary);
            font-weight: 600;
        }

        .mode-options {
            flex-wrap: wrap;
        }

        .mode-options .setting-btn {
            min-width: 45%;
        }

        /* ===== COMBO DISPLAY ===== */
        .combo-display {
            min-height: 35px;
            margin-bottom: 8px;
            text-align: center;
        }

        .combo-text {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            animation: combo-pop 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
        }

        .combo-text.combo-1 { background: rgba(0, 255, 136, 0.2); color: var(--primary); box-shadow: 0 0 20px var(--primary-dim); }
        .combo-text.combo-2 { background: rgba(255, 215, 0, 0.2); color: var(--gold); font-size: 1.1rem; box-shadow: 0 0 25px rgba(255, 215, 0, 0.3); }
        .combo-text.combo-3 { background: rgba(255, 165, 0, 0.25); color: #ffa500; font-size: 1.2rem; box-shadow: 0 0 30px rgba(255, 165, 0, 0.4); }
        .combo-text.combo-4 { background: rgba(255, 69, 0, 0.25); color: #ff4500; font-size: 1.3rem; box-shadow: 0 0 35px rgba(255, 69, 0, 0.4); }
        .combo-text.combo-5 {
            background: linear-gradient(135deg, rgba(255, 0, 85, 0.3), rgba(255, 100, 0, 0.3));
            color: var(--accent);
            font-size: 1.4rem;
            box-shadow: 0 0 40px rgba(255, 0, 85, 0.5);
            animation: combo-pop 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55), rainbow-glow 1s ease infinite;
        }

        @keyframes combo-pop {
            0% { transform: scale(0.5) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes rainbow-glow {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }

        .combo-bar {
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }

        .combo-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--gold));
            background-size: 200% 100%;
            border-radius: 3px;
            transition: width 0.1s linear;
            animation: bar-shimmer 2s linear infinite;
        }

        @keyframes bar-shimmer {
            0% { background-position: 0% 0; }
            100% { background-position: 200% 0; }
        }

        /* ===== POWER-UPS ===== */
        .active-powerups {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 12px;
            min-height: 35px;
            flex-wrap: wrap;
        }

        .powerup-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            animation: powerup-pulse 1.5s ease infinite;
            backdrop-filter: blur(10px);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .powerup-indicator.speed {
            background: rgba(0, 150, 255, 0.2);
            color: #00aaff;
            border: 1px solid rgba(0, 150, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.3);
        }
        .powerup-indicator.shield {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            border: 1px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        .powerup-indicator.double {
            background: rgba(255, 215, 0, 0.2);
            color: var(--gold);
            border: 1px solid rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        .powerup-indicator.slow {
            background: rgba(180, 0, 255, 0.2);
            color: #b400ff;
            border: 1px solid rgba(180, 0, 255, 0.5);
            box-shadow: 0 0 20px rgba(180, 0, 255, 0.3);
        }

        @keyframes powerup-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.85; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ===== CANVAS ===== */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-8px, -6px) rotate(-1deg); }
            20% { transform: translate(8px, -4px) rotate(1deg); }
            30% { transform: translate(-6px, 8px) rotate(0deg); }
            40% { transform: translate(6px, 6px) rotate(1deg); }
            50% { transform: translate(-4px, -8px) rotate(-1deg); }
            60% { transform: translate(4px, 4px) rotate(0deg); }
            70% { transform: translate(-8px, 2px) rotate(-1deg); }
            80% { transform: translate(6px, -4px) rotate(1deg); }
            90% { transform: translate(-2px, 6px) rotate(0deg); }
        }

        @keyframes flash-red {
            0%, 100% { border-color: var(--primary); box-shadow: 0 0 40px var(--primary-dim), inset 0 0 60px rgba(0, 255, 136, 0.1); }
            50% { border-color: var(--accent); box-shadow: 0 0 60px rgba(255, 0, 85, 0.6), inset 0 0 80px rgba(255, 0, 85, 0.2); }
        }

        .canvas-area {
            position: relative;
            display: inline-block;
        }

        .canvas-wrapper {
            display: inline-block;
            border: 2px solid var(--primary);
            border-radius: 14px;
            box-shadow:
                0 25px 80px rgba(0, 0, 0, 0.6),
                0 0 40px var(--primary-dim);
            line-height: 0;
        }

        .canvas-area::before {
            content: '';
            position: absolute;
            top: -30px;
            left: -30px;
            right: -30px;
            bottom: -30px;
            background: radial-gradient(ellipse at center, var(--primary-dim) 0%, transparent 60%);
            border-radius: 30px;
            z-index: -1;
            filter: blur(50px);
            opacity: 0.3;
            pointer-events: none;
        }

        .canvas-wrapper.shake {
            animation: shake 0.5s ease-in-out;
        }

        canvas {
            border: none;
            border-radius: 12px;
            background: #08080f;
            display: block;
            transition: all 0.3s ease;
        }

        canvas.flash {
            animation: flash-red 0.15s ease-in-out 3;
        }

        .controls {
            margin-top: 16px;
            color: rgba(255, 255, 255, 0.35);
            font-size: 0.8rem;
            letter-spacing: 1px;
        }

        .controls p {
            margin: 4px 0;
            transition: color 0.3s ease;
        }

        .controls p:hover {
            color: rgba(255, 255, 255, 0.6);
        }

        .fullscreen-btn {
            margin-top: 12px;
            background: rgba(255, 255, 255, 0.03);
            color: rgba(255, 255, 255, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 10px 20px;
            font-size: 0.7rem;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .fullscreen-btn svg {
            transition: transform 0.3s ease;
            opacity: 0.6;
        }

        .fullscreen-btn:hover svg {
            opacity: 1;
        }

        /* ===== FULLSCREEN MODE ===== */
        .game-container:fullscreen,
        .game-container:-webkit-full-screen {
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container:fullscreen .canvas-area,
        .game-container:-webkit-full-screen .canvas-area {
            transform: scale(1.5);
        }

        .game-container:fullscreen .header,
        .game-container:-webkit-full-screen .header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .game-container:fullscreen .score-board,
        .game-container:-webkit-full-screen .score-board {
            margin-bottom: 30px;
        }

        .game-container:fullscreen .controls,
        .game-container:-webkit-full-screen .controls {
            margin-top: 40px;
        }

        .game-container:fullscreen .mobile-controls,
        .game-container:-webkit-full-screen .mobile-controls {
            margin-top: 30px;
        }

        /* ===== SIDE PANELS ===== */
        .left-panel, .side-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .left-panel {
            width: 300px;
            min-width: 300px;
            animation: slide-in-left 0.6s ease-out;
            animation-delay: 2.2s;
            opacity: 0;
            animation-fill-mode: forwards;
        }

        .side-panel {
            width: 320px;
            min-width: 320px;
            animation: slide-in-right 0.6s ease-out;
            animation-delay: 2.2s;
            opacity: 0;
            animation-fill-mode: forwards;
        }

        @keyframes slide-in-left {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* ===== PREMIUM CARDS ===== */
        .leaderboard, .settings, .daily-challenge {
            background: linear-gradient(135deg, rgba(255,255,255,0.04) 0%, rgba(255,255,255,0.01) 100%);
            backdrop-filter: blur(40px);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 16px;
            padding: 20px;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.05);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .leaderboard::before, .settings::before, .daily-challenge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 20px;
            right: 20px;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
            opacity: 0.5;
        }

        .leaderboard:hover, .settings:hover, .daily-challenge:hover {
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow:
                0 30px 80px rgba(0, 0, 0, 0.5),
                0 0 60px var(--primary-dim);
        }

        .daily-challenge {
            border-color: transparent;
        }

        .daily-challenge::before {
            background: linear-gradient(90deg, transparent, var(--accent-orange), var(--gold), transparent) !important;
        }

        .daily-challenge h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            color: var(--accent-orange);
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .challenge-desc {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            margin-bottom: 12px;
            text-align: center;
        }

        .challenge-desc .challenge-type {
            color: var(--accent-orange);
            font-weight: 700;
        }

        .challenge-progress {
            margin-bottom: 10px;
        }

        .challenge-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .challenge-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-orange), var(--gold));
            border-radius: 4px;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
        }

        .challenge-status {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            display: block;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
        }

        .challenge-status.completed {
            color: var(--primary);
            font-weight: 700;
            text-shadow: 0 0 10px var(--primary-dim);
        }

        .challenge-reward {
            text-align: center;
            font-size: 0.95rem;
            padding-top: 10px;
            border-top: 1px solid var(--glass-border);
            margin-top: 10px;
        }

        .challenge-reward .streak {
            color: var(--gold);
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
        }

        /* ===== LEADERBOARD ===== */
        .leaderboard h2, .settings h2 {
            font-family: 'Inter', sans-serif;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 16px;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .leaderboard h2::before {
            content: '';
            width: 24px;
            height: 24px;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23ffd700' viewBox='0 0 24 24'%3E%3Cpath d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z'/%3E%3C/svg%3E") center/contain no-repeat;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.5));
        }

        .leaderboard-list {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .leaderboard-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .leaderboard-item.current-user {
            background: linear-gradient(135deg, var(--primary-dim), rgba(0, 255, 136, 0.05));
            border-color: var(--primary-dim);
        }

        .rank {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            width: 28px;
            text-align: center;
        }

        .rank.gold {
            color: var(--gold);
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }
        .rank.silver {
            color: #e0e0e0;
            text-shadow: 0 0 10px rgba(224, 224, 224, 0.4);
        }
        .rank.bronze {
            color: #cd9a6b;
            text-shadow: 0 0 10px rgba(205, 154, 107, 0.4);
        }
        .rank.normal {
            color: rgba(255, 255, 255, 0.3);
        }

        .player-avatar {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .leaderboard-item:hover .player-avatar {
            border-color: var(--primary-dim);
        }

        .player-info {
            flex: 1;
            overflow: hidden;
        }

        .player-name {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.85rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-score {
            color: var(--primary);
            font-weight: 600;
            font-size: 0.95rem;
            font-family: 'Orbitron', sans-serif;
        }

        .no-scores {
            color: rgba(255, 255, 255, 0.3);
            text-align: center;
            padding: 25px;
            font-style: italic;
        }

        .loading {
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
            padding: 25px;
        }

        /* ===== SETTINGS ===== */
        .setting-group {
            margin-bottom: 16px;
        }

        .setting-group:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.65rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .setting-options {
            display: flex;
            gap: 6px;
        }

        .setting-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.06);
            color: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.75rem;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            position: relative;
            overflow: hidden;
        }

        .setting-btn:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
        }

        .setting-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: #000;
            font-weight: 600;
            box-shadow: 0 4px 20px var(--primary-dim);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }

        .toggle {
            position: relative;
            width: 44px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
        }

        .toggle:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .toggle.active {
            background: var(--primary);
            box-shadow: 0 0 20px var(--primary-dim);
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .toggle.active::after {
            left: 29px;
            background: var(--bg-dark);
        }

        .apply-btn {
            width: 100%;
            padding: 12px;
            background: var(--primary);
            border: none;
            color: #000;
            font-weight: 600;
            font-size: 0.75rem;
            font-family: 'Inter', sans-serif;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        .apply-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px var(--primary-dim);
        }

        .apply-btn:active {
            transform: translateY(0);
        }

        .settings-note {
            color: rgba(255, 255, 255, 0.25);
            font-size: 0.7rem;
            text-align: center;
            margin-top: 8px;
        }

        /* ===== THEME SELECTOR ===== */
        .theme-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }

        .theme-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: var(--glass);
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .theme-btn:hover {
            transform: translateY(-4px);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .theme-btn.active {
            border-color: var(--primary);
            box-shadow: 0 0 20px var(--primary-dim);
        }

        .theme-preview {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .theme-preview-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: 10px 10px;
            opacity: 0.3;
        }

        .theme-preview-snake {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 30px;
            height: 6px;
            border-radius: 3px;
        }

        /* Theme preview colors */
        .neon-preview {
            background: linear-gradient(135deg, #0a0a1a, #1a1a3e);
        }
        .neon-preview .theme-preview-grid {
            background-image: linear-gradient(rgba(0, 255, 136, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 255, 136, 0.1) 1px, transparent 1px);
        }
        .neon-preview .theme-preview-snake {
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            box-shadow: 0 0 10px #00ff88;
        }

        .retro-preview {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
        }
        .retro-preview .theme-preview-grid {
            background-image: linear-gradient(rgba(255, 204, 0, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255, 204, 0, 0.1) 1px, transparent 1px);
        }
        .retro-preview .theme-preview-snake {
            background: linear-gradient(90deg, #ffcc00, #ff6b35);
            box-shadow: 0 0 10px #ffcc00;
        }

        .ocean-preview {
            background: linear-gradient(135deg, #03045e, #023e8a);
        }
        .ocean-preview .theme-preview-grid {
            background-image: linear-gradient(rgba(0, 180, 216, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 180, 216, 0.1) 1px, transparent 1px);
        }
        .ocean-preview .theme-preview-snake {
            background: linear-gradient(90deg, #00b4d8, #90e0ef);
            box-shadow: 0 0 10px #00b4d8;
        }

        .forest-preview {
            background: linear-gradient(135deg, #1b2a1b, #2d4a2d);
        }
        .forest-preview .theme-preview-grid {
            background-image: linear-gradient(rgba(128, 185, 24, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(128, 185, 24, 0.1) 1px, transparent 1px);
        }
        .forest-preview .theme-preview-snake {
            background: linear-gradient(90deg, #80b918, #55a630);
            box-shadow: 0 0 10px #80b918;
        }

        .sunset-preview {
            background: linear-gradient(135deg, #2b1055, #4a1a7a);
        }
        .sunset-preview .theme-preview-grid {
            background-image: linear-gradient(rgba(247, 37, 133, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(247, 37, 133, 0.1) 1px, transparent 1px);
        }
        .sunset-preview .theme-preview-snake {
            background: linear-gradient(90deg, #f72585, #7209b7);
            box-shadow: 0 0 10px #f72585;
        }

        .theme-name {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .theme-btn.active .theme-name {
            color: var(--primary);
        }

        /* ===== SKIN SELECTOR ===== */
        .skin-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .skin-btn {
            width: 100%;
            aspect-ratio: 1;
            padding: 5px;
            background: var(--glass);
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .skin-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.4s, height 0.4s;
        }

        .skin-btn:hover::after {
            width: 100px;
            height: 100px;
        }

        .skin-btn:hover {
            transform: scale(1.1) rotate(5deg);
            border-color: rgba(255, 255, 255, 0.3);
            z-index: 1;
        }

        .skin-btn.active {
            border-color: var(--primary);
            box-shadow: 0 0 25px var(--primary-dim), inset 0 0 20px var(--primary-dim);
            transform: scale(1.05);
        }

        .skin-preview {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            position: relative;
            z-index: 1;
        }

        /* Power-up Legend */
        .powerup-legend {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .powerup-legend h3 {
            color: #00ff88;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.8rem;
            color: #888;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.speed { background: #00aaff; }
        .legend-dot.shield { background: #00ffff; }
        .legend-dot.double { background: #ffd700; }
        .legend-dot.slow { background: #b400ff; }

        /* Game Over Modal */
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.7);
        }

        .game-over-content {
            background: var(--bg-card);
            backdrop-filter: blur(30px);
            padding: 40px 50px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            text-align: center;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6), 0 0 100px rgba(255, 0, 85, 0.2);
            animation: modal-appear 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            position: relative;
        }

        .game-over-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, transparent, var(--accent), var(--accent-orange), transparent);
            border-radius: 25px 25px 0 0;
        }

        @keyframes modal-appear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .game-over h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent);
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 30px rgba(255, 0, 85, 0.5);
        }

        .game-over p {
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 12px;
            font-size: 1.1rem;
        }

        .game-over p span {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary);
            font-weight: 700;
            font-size: 1.8rem;
        }

        .game-over .new-record {
            color: var(--gold);
            font-size: 1.3rem;
            margin-bottom: 20px;
            font-weight: 700;
            animation: pulse 1s ease infinite;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .restart-btn {
            background: linear-gradient(135deg, var(--primary), #00cc6a);
            color: var(--bg-dark);
            border: none;
            padding: 16px 50px;
            font-size: 1.1rem;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-top: 15px;
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
        }

        .restart-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s ease;
        }

        .restart-btn:hover::before {
            left: 100%;
        }

        .restart-btn:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 20px 50px var(--primary-dim);
        }

        .restart-btn:active {
            transform: translateY(0) scale(0.98);
        }

        /* Username Modal */
        .username-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .username-modal.show {
            display: flex;
        }

        .username-modal-content {
            background: var(--bg-card);
            backdrop-filter: blur(30px);
            padding: 40px 50px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            text-align: center;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6), 0 0 100px var(--primary-dim);
            animation: modal-appear 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        .username-modal-content h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary);
            font-size: 1.8rem;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .username-modal-content p {
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 25px;
            font-size: 0.95rem;
        }

        .username-modal-content input {
            width: 100%;
            padding: 14px 20px;
            font-size: 1.1rem;
            font-family: 'Rajdhani', sans-serif;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            color: #fff;
            outline: none;
            transition: all 0.3s ease;
            margin-bottom: 25px;
        }

        .username-modal-content input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 20px var(--primary-dim);
        }

        .username-modal-content input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .username-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .username-btn {
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: 600;
            font-family: 'Rajdhani', sans-serif;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
        }

        .username-btn.cancel {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
        }

        .username-btn.cancel:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .username-btn.save {
            background: linear-gradient(135deg, var(--primary), #00cc6a);
            color: var(--bg-dark);
        }

        .username-btn.save:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px var(--primary-dim);
        }

        /* ===== MULTIPLAYER STYLES ===== */

        /* Multiplayer Controls in Settings */
        .multiplayer-controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid var(--glass-border);
        }

        .mp-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .mp-btn {
            background: linear-gradient(135deg, var(--primary), #00cc6a);
            color: var(--bg-dark);
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mp-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px var(--primary-dim);
        }

        .mp-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .mp-divider {
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .mp-join-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .room-code-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 14px 16px;
            color: var(--text-primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            text-align: center;
            box-sizing: border-box;
        }

        .room-code-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 20px var(--primary-dim);
        }

        .room-code-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
            text-transform: none;
            letter-spacing: normal;
        }

        .join-room-btn {
            background: var(--secondary);
            width: 100%;
        }

        /* Multiplayer Lobby Modal */
        .mp-lobby-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
            padding: 20px;
            box-sizing: border-box;
        }

        .mp-lobby-modal.show {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
        }

        .mp-lobby-content {
            background: var(--bg-card);
            backdrop-filter: blur(30px);
            padding: 25px 30px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            width: 90%;
            max-width: 450px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6), 0 0 100px var(--primary-dim);
            animation: lobby-appear 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes lobby-appear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* Custom scrollbar for lobby content */
        .mp-lobby-content::-webkit-scrollbar {
            width: 6px;
        }
        .mp-lobby-content::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        .mp-lobby-content::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
        }

        .mp-lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .mp-lobby-header h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary);
            font-size: 1.5rem;
            letter-spacing: 2px;
            margin: 0;
        }

        .mp-lobby-close {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            line-height: 1;
        }

        .mp-lobby-close:hover {
            color: var(--accent);
            transform: scale(1.1);
        }

        .mp-room-code-section {
            margin-bottom: 20px;
        }

        .mp-room-code-section label {
            display: block;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .mp-room-code-display {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
        }

        .mp-room-code-display span {
            flex: 1;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            color: var(--primary);
            letter-spacing: 4px;
        }

        .mp-copy-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.3s ease;
        }

        .mp-copy-btn:hover {
            background: var(--primary);
            color: var(--bg-dark);
        }

        .mp-game-settings {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .mp-setting-badge {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mp-host-settings {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid var(--glass-border);
        }

        .mp-setting-group {
            margin-bottom: 8px;
        }

        .mp-setting-group:last-child {
            margin-bottom: 0;
        }

        .mp-setting-group label {
            display: block;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .mp-setting-buttons {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .mp-setting-btn {
            padding: 4px 10px;
            border: 1px solid var(--glass-border);
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s ease;
        }

        .mp-setting-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary);
        }

        .mp-setting-btn.active {
            background: var(--primary);
            color: #000;
            border-color: var(--primary);
            font-weight: bold;
        }

        .mp-players-section {
            margin-bottom: 20px;
        }

        .mp-players-section label {
            display: block;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .mp-players-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mp-player-item {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
        }

        .mp-player-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            box-shadow: 0 0 15px currentColor;
        }

        .mp-player-name {
            flex: 1;
            font-weight: 500;
            color: var(--text-primary);
        }

        .mp-player-host {
            font-size: 0.7rem;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mp-player-ready {
            font-size: 0.8rem;
            padding: 4px 10px;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mp-player-ready.ready {
            background: rgba(0, 255, 136, 0.2);
            color: var(--primary);
        }

        .mp-player-ready.waiting {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
        }

        .mp-kick-btn {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.4);
            color: #ff4444;
            padding: 4px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .mp-kick-btn:hover {
            background: rgba(255, 68, 68, 0.4);
        }

        .spectator-leave-btn {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ff4444, #cc3333);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            z-index: 1001;
            transition: all 0.2s;
        }

        .spectator-leave-btn:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }

        .mp-lobby-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mp-lobby-actions .mp-btn {
            flex: 1;
        }

        .mp-ready-btn.ready {
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid var(--primary);
            color: var(--primary);
        }

        .mp-leave-btn {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
        }

        .mp-leave-btn:hover {
            background: var(--accent);
            color: white;
            box-shadow: 0 8px 25px rgba(255, 0, 85, 0.3);
        }

        .mp-start-btn {
            background: linear-gradient(135deg, var(--gold), #ff9900);
        }

        .mp-lobby-status {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85rem;
            font-style: italic;
        }

        /* Multiplayer HUD */
        .mp-hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 100;
            pointer-events: none;
        }

        .mp-lives-display {
            display: flex;
            gap: 8px;
        }

        .mp-life-heart {
            font-size: 1.5rem;
            filter: drop-shadow(0 0 5px currentColor);
            transition: all 0.3s ease;
        }

        .mp-life-heart.lost {
            opacity: 0.3;
            filter: grayscale(1);
        }

        .mp-scores-display {
            display: flex;
            gap: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .mp-score-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mp-score-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .mp-score-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .mp-score-item.eliminated .mp-score-value {
            opacity: 0.4;
            text-decoration: line-through;
        }

        /* Spectating Indicator */
        .spectating-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 85, 0.2);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 100;
            animation: pulse 2s ease-in-out infinite;
        }

        /* Multiplayer Results Modal */
        .mp-results-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .mp-results-modal.show {
            display: flex;
        }

        .mp-results-content {
            background: var(--bg-card);
            backdrop-filter: blur(30px);
            padding: 40px 50px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            text-align: center;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
            animation: modal-appear 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            min-width: 350px;
        }

        .mp-results-content h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent);
            font-size: 2rem;
            margin-bottom: 20px;
            letter-spacing: 3px;
        }

        .mp-results-winner {
            margin-bottom: 25px;
        }

        .mp-results-winner .winner-label {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .mp-results-winner .winner-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            color: var(--gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .mp-results-rankings {
            margin-bottom: 25px;
        }

        .mp-ranking-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .mp-ranking-item.first {
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .mp-ranking-position {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            width: 30px;
        }

        .mp-ranking-position.gold { color: var(--gold); }
        .mp-ranking-position.silver { color: #c0c0c0; }
        .mp-ranking-position.bronze { color: #cd7f32; }

        .mp-ranking-name {
            flex: 1;
            text-align: left;
            margin-left: 10px;
        }

        .mp-ranking-score {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary);
        }

        .mp-results-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .mp-results-actions .mp-btn {
            min-width: 120px;
        }

        /* Edit Username Button in User Info */
        .edit-username-btn {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            padding: 4px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }

        .edit-username-btn:hover {
            color: var(--primary);
        }

        /* Leaderboard Game Settings */
        .player-settings {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 3px;
        }

        .setting-badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .setting-badge.mode {
            background: rgba(0, 255, 136, 0.2);
            color: var(--primary);
        }

        .setting-badge.speed {
            background: rgba(0, 212, 255, 0.2);
            color: var(--secondary);
        }

        .setting-badge.size {
            background: rgba(255, 102, 0, 0.2);
            color: var(--accent-orange);
        }

        .setting-badge.obstacles {
            background: rgba(255, 0, 85, 0.2);
            color: var(--accent);
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 30px;
            right: 30px;
            background: linear-gradient(135deg, rgba(30, 20, 60, 0.95), rgba(50, 30, 80, 0.95));
            backdrop-filter: blur(20px);
            border: 2px solid var(--gold);
            border-radius: 20px;
            padding: 20px 28px;
            display: flex;
            align-items: center;
            gap: 18px;
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 200;
            box-shadow: 0 15px 50px rgba(255, 215, 0, 0.3), 0 0 60px rgba(255, 215, 0, 0.2);
        }

        .achievement-popup.show {
            transform: translateX(0);
            opacity: 1;
        }

        .achievement-icon {
            font-size: 3rem;
            animation: trophy-bounce 0.6s ease infinite;
        }

        @keyframes trophy-bounce {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-8px) rotate(-5deg); }
            75% { transform: translateY(-4px) rotate(5deg); }
        }

        .achievement-title {
            color: var(--gold);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 4px;
        }

        .achievement-name {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 700;
        }

        /* Achievements Toggle Button */
        .achievements-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ffd700;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 150;
        }

        .achievements-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        /* Achievements Panel */
        .achievements-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            width: 300px;
            max-height: 70vh;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 15px;
            display: none;
            z-index: 150;
            overflow-y: auto;
        }

        .achievements-panel.show {
            display: block;
        }

        .achievements-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }

        .achievements-header h3 {
            color: #ffd700;
            margin: 0;
        }

        .achievements-close {
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.2s;
        }

        .achievements-close:hover {
            color: #fff;
        }

        .achievement-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.2s ease;
        }

        .achievement-item.locked {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .achievement-item.unlocked {
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .achievement-item-icon {
            font-size: 1.8rem;
            min-width: 40px;
            text-align: center;
        }

        .achievement-item-info {
            flex: 1;
        }

        .achievement-item-name {
            color: #fff;
            font-size: 0.95rem;
            font-weight: bold;
        }

        .achievement-item-desc {
            color: #888;
            font-size: 0.8rem;
        }

        .achievement-item-status {
            color: #ffd700;
            font-size: 0.75rem;
        }

        /* Mobile Controls - Hidden by default */
        .mobile-controls {
            display: none;
        }

        .mobile-btn {
            width: 70px;
            height: 70px;
            background: rgba(0, 255, 136, 0.25);
            border: 2px solid var(--primary);
            border-radius: 15px;
            color: var(--primary);
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.1s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }

        .mobile-btn:active {
            background: var(--primary);
            color: #1a1a2e;
            transform: scale(0.95);
        }

        .btn-row {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        /* D-Pad Layout */
        .mobile-dpad {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            width: 100%;
        }

        .dpad-row {
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
        }

        .mobile-pause-btn {
            background: rgba(255, 255, 255, 0.15) !important;
            border-color: var(--glass-border) !important;
            color: var(--text-secondary) !important;
            font-size: 1rem !important;
        }

        .mobile-pause-btn:active {
            background: var(--secondary) !important;
            color: #1a1a2e !important;
        }

        /* Mobile Toggle Switch */
        .mobile-toggle input:checked + .mobile-toggle-slider {
            background: var(--primary) !important;
        }

        .mobile-toggle input:checked ~ .mobile-toggle-knob {
            transform: translateX(22px);
            background: #fff;
        }

        /* Mobile Settings Toggle Button */
        .mobile-settings-toggle {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            width: 44px;
            height: 44px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1.3rem;
            cursor: pointer;
            z-index: 1000;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-settings-toggle.active {
            background: var(--primary);
            color: #1a1a2e;
        }

        /* Mobile Quick Play Button */
        .mobile-play-btn {
            display: none;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 12px;
            color: #0a0a1a;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .mobile-play-btn:active {
            transform: scale(0.98);
        }

        /* Mobile Settings Panel */
        .mobile-settings-panel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 80%;
            max-width: 320px;
            height: 100%;
            background: linear-gradient(180deg, #0d0d1a 0%, #1a1a3e 100%);
            border-right: 2px solid var(--primary-dim);
            z-index: 9999;
            overflow-y: auto;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            padding: 60px 15px 20px;
        }

        .mobile-settings-panel.active {
            transform: translateX(0);
        }

        .mobile-settings-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9998;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mobile-settings-overlay.active {
            opacity: 1;
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .left-panel, .side-panel {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
            }

            .leaderboard, .settings, .daily-challenge {
                width: 100%;
                max-width: 350px;
            }
        }

        /* ===== MOBILE LAYOUT (max-width: 600px) ===== */
        @media (max-width: 600px) {
            html {
                height: 100%;
                overflow: hidden;
            }

            body {
                padding: 0;
                min-height: 100vh;
                min-height: calc(var(--vh, 1vh) * 100);
                height: 100%;
                overflow-x: hidden;
                overflow-y: auto;
                align-items: flex-start;
                justify-content: flex-start;
                -webkit-overflow-scrolling: touch;
            }

            .main-container {
                padding: 10px;
                padding-top: 10px;
                padding-bottom: 240px;
                min-height: auto;
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
            }

            /* Hide side panels on mobile */
            .left-panel,
            .side-panel {
                display: none !important;
            }

            /* Show mobile-specific elements */
            .mobile-controls {
                display: flex;
                flex-direction: column;
                align-items: center;
                position: fixed;
                bottom: 20px;
                left: 0;
                right: 0;
                background: linear-gradient(to top, rgba(10, 10, 26, 0.98) 0%, rgba(10, 10, 26, 0.9) 80%, transparent 100%);
                padding: 15px 10px 25px;
                z-index: 100;
            }

            .mobile-settings-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .mobile-settings-panel {
                display: block;
            }

            .mobile-settings-overlay {
                display: block;
                pointer-events: none;
            }

            .mobile-settings-overlay.active {
                pointer-events: auto;
            }

            .mobile-play-btn {
                display: block;
            }

            /* Compact game container */
            .game-container {
                padding: 10px;
                border-radius: 15px;
                width: 100%;
                max-width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            /* Compact header */
            .header {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 5px 10px;
                margin-bottom: 8px;
                width: 100%;
                box-sizing: border-box;
            }

            .header h1 {
                font-size: 1.4rem;
                margin: 0;
            }

            #authContainer {
                transform: scale(0.85);
                transform-origin: right center;
            }

            .auth-btn {
                padding: 6px 10px;
                font-size: 0.75rem;
            }

            /* Compact score board */
            .score-board {
                flex-wrap: wrap;
                gap: 8px;
                padding: 8px;
                margin-bottom: 8px;
                font-size: 0.85rem;
                width: 100%;
                box-sizing: border-box;
                justify-content: center;
            }

            /* Canvas sizing for mobile */
            .canvas-area {
                margin: 0;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .canvas-wrapper {
                width: 100%;
                max-width: calc(100vw - 20px);
                display: flex;
                justify-content: center;
                align-items: center;
            }

            #gameCanvas {
                width: 100% !important;
                height: auto !important;
                max-width: 90vw;
                max-height: calc(var(--vh, 1vh) * 100 - 370px);
            }

            /* Hide desktop controls text */
            .controls {
                display: none !important;
            }

            /* Mode indicator compact */
            .mode-indicator {
                font-size: 0.7rem;
                padding: 4px 8px;
            }

            /* Game over overlay */
            .game-over {
                padding: 15px;
            }

            .game-over-content h2 {
                font-size: 1.5rem;
            }

            .restart-btn {
                padding: 12px 30px;
                font-size: 1rem;
            }

            /* Power-ups display */
            .active-powerups {
                flex-wrap: wrap;
                gap: 5px;
            }

            .powerup-indicator {
                font-size: 0.7rem;
                padding: 3px 8px;
            }

            /* Help button repositioned for mobile */
            .help-btn {
                bottom: 230px;
                right: 10px;
                width: 40px;
                height: 40px;
                font-size: 1.2rem;
            }

            /* Move achievements toggle below header on mobile */
            .achievements-toggle {
                left: auto;
                right: 10px;
                top: 70px;
                width: 40px;
                height: 40px;
                font-size: 1.1rem;
            }

            /* Adjust achievements panel position on mobile */
            .achievements-panel {
                left: 10px;
                right: 10px;
                top: 120px;
                width: auto;
                max-width: none;
                max-height: 60vh;
            }
        }

        /* Extra small phones */
        @media (max-width: 380px) {
            .mobile-btn {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }

            .header h1 {
                font-size: 1.2rem;
            }

            .score-board {
                font-size: 0.75rem;
            }

            #gameCanvas {
                max-height: calc(var(--vh, 1vh) * 100 - 340px);
            }

            .help-btn {
                bottom: 230px;
            }
        }

        /* ===== GUIDE POPUP MODAL ===== */
        .guide-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .guide-modal.active {
            display: flex;
            opacity: 1;
        }

        .guide-container {
            background: linear-gradient(145deg, #0d0d1a 0%, #1a1a3e 100%);
            border: 2px solid var(--primary);
            border-radius: 20px;
            max-width: 800px;
            max-height: 85vh;
            width: 100%;
            overflow: hidden;
            box-shadow: 0 0 40px var(--primary-dim), inset 0 0 60px rgba(0, 0, 0, 0.5);
            animation: guide-slide-in 0.3s ease;
        }

        @keyframes guide-slide-in {
            from {
                transform: translateY(-30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .guide-header {
            background: linear-gradient(90deg, var(--primary-dim), transparent);
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--glass-border);
        }

        .guide-header h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--primary);
            margin: 0;
            text-shadow: 0 0 20px var(--primary-dim);
        }

        .guide-close-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .guide-close-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            transform: rotate(90deg);
        }

        .guide-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--glass-border);
            overflow-x: auto;
        }

        .guide-tab {
            flex: 1;
            min-width: 100px;
            padding: 15px 20px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }

        .guide-tab:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .guide-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: rgba(0, 255, 136, 0.05);
        }

        .guide-content {
            padding: 25px;
            overflow-y: auto;
            max-height: calc(85vh - 140px);
        }

        .guide-section {
            display: none;
        }

        .guide-section.active {
            display: block;
            animation: guide-fade-in 0.3s ease;
        }

        @keyframes guide-fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .guide-section h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            color: var(--secondary);
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--glass-border);
        }

        .guide-section p {
            color: var(--text-secondary);
            line-height: 1.7;
            margin-bottom: 15px;
        }

        .guide-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .guide-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 15px;
            transition: all 0.2s ease;
        }

        .guide-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.1);
        }

        .guide-card-icon {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .guide-card-title {
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            font-size: 1rem;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .guide-card-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .guide-key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            padding: 4px 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: var(--primary);
            margin: 2px;
        }

        .guide-color-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .guide-list {
            list-style: none;
            padding: 0;
            margin: 0 0 20px 0;
        }

        .guide-list li {
            padding: 10px 15px;
            background: var(--glass);
            border-radius: 8px;
            margin-bottom: 8px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .guide-list li strong {
            color: var(--primary);
            min-width: 100px;
        }

        .guide-tip {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 212, 255, 0.1));
            border: 1px solid var(--primary-dim);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }

        .guide-tip-title {
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .guide-tip p {
            margin: 0;
            font-size: 0.9rem;
        }

        /* Help Button */
        .help-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            color: #0a0a1a;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 9998;
            box-shadow: 0 4px 20px var(--primary-dim);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px var(--primary-dim);
        }

        .help-btn:active {
            transform: scale(0.95);
        }

        @media (max-width: 600px) {
            .guide-container {
                max-height: 90vh;
                border-radius: 15px;
            }

            .guide-header h2 {
                font-size: 1.2rem;
            }

            .guide-tab {
                padding: 12px 15px;
                font-size: 0.85rem;
            }

            .guide-content {
                padding: 15px;
            }

            .guide-grid {
                grid-template-columns: 1fr;
            }

            .help-btn {
                width: 45px;
                height: 45px;
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <script>
        // Set viewport height variable immediately to prevent layout shift
        (function() {
            var vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', vh + 'px');
        })();
    </script>
    <!-- Pixel Art Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <!-- Scanlines Overlay -->
        <div class="loading-scanlines"></div>

        <!-- Retro Frame Container -->
        <div class="loading-frame">
            <!-- Snake Loader -->
            <div class="snake-loader">
                <!-- Rotating Snake Circle -->
                <div class="snake-circle">
                    <!-- Head -->
                    <div class="snake-segment head"></div>
                    <!-- Body segments (gradient from bright to dark green) -->
                    <div class="snake-segment body-1"></div>
                    <div class="snake-segment body-2"></div>
                    <div class="snake-segment body-3"></div>
                    <div class="snake-segment body-4"></div>
                    <div class="snake-segment body-5"></div>
                    <div class="snake-segment body-6"></div>
                    <div class="snake-segment body-7"></div>
                    <div class="snake-segment body-8"></div>
                    <!-- Tail -->
                    <div class="snake-segment tail"></div>
                </div>
                <!-- Pulsing Food in Center -->
                <div class="pixel-food"></div>
            </div>

            <!-- Loading Text with Animated Dots -->
            <div class="loading-text-pixel">
                LOADING<span class="loading-dots"><span>.</span><span>.</span><span>.</span></span>
            </div>
        </div>
    </div>

    <!-- Guide Modal -->
    <div class="guide-modal" id="guideModal">
        <div class="guide-container">
            <div class="guide-header">
                <h2>How to Play</h2>
                <button class="guide-close-btn" id="guideCloseBtn">&times;</button>
            </div>
            <div class="guide-tabs">
                <button class="guide-tab active" data-tab="basics">Basics</button>
                <button class="guide-tab" data-tab="controls">Controls</button>
                <button class="guide-tab" data-tab="modes">Game Modes</button>
                <button class="guide-tab" data-tab="settings">Settings</button>
                <button class="guide-tab" data-tab="items">Food & Power-ups</button>
                <button class="guide-tab" data-tab="multiplayer">Multiplayer</button>
            </div>
            <div class="guide-content">
                <!-- BASICS TAB -->
                <div class="guide-section active" id="guide-basics">
                    <h3>Welcome to Snake!</h3>
                    <p>Snake is a classic arcade game where you control a snake that grows longer as it eats food. The goal is to eat as much food as possible without crashing into walls or your own tail!</p>

                    <div class="guide-grid">
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Objective</div>
                            <div class="guide-card-desc">Eat food to grow longer and score points. Survive as long as possible!</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Game Over</div>
                            <div class="guide-card-desc">You die if you hit a wall, an obstacle, or your own body.</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Leaderboard</div>
                            <div class="guide-card-desc">Sign in with Google to save your scores and compete globally!</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Power-ups</div>
                            <div class="guide-card-desc">Collect special items that appear every 10 seconds for temporary boosts!</div>
                        </div>
                    </div>

                    <div class="guide-tip">
                        <div class="guide-tip-title"> Pro Tip</div>
                        <p>Plan your moves ahead! As your snake grows longer, you'll need more space to maneuver. Try to keep the center of the map clear.</p>
                    </div>
                </div>

                <!-- CONTROLS TAB -->
                <div class="guide-section" id="guide-controls">
                    <h3>Keyboard Controls</h3>
                    <p>Use either Arrow Keys or WASD to control your snake's direction:</p>

                    <ul class="guide-list">
                        <li><strong>Move Up</strong> <span class="guide-key"></span> or <span class="guide-key">W</span></li>
                        <li><strong>Move Down</strong> <span class="guide-key"></span> or <span class="guide-key">S</span></li>
                        <li><strong>Move Left</strong> <span class="guide-key"></span> or <span class="guide-key">A</span></li>
                        <li><strong>Move Right</strong> <span class="guide-key"></span> or <span class="guide-key">D</span></li>
                        <li><strong>Pause Game</strong> <span class="guide-key">Space</span></li>
                        <li><strong>Fullscreen</strong> <span class="guide-key">F</span></li>
                        <li><strong>Exit Fullscreen</strong> <span class="guide-key">Esc</span></li>
                    </ul>

                    <h3>Mobile Controls</h3>
                    <p>On mobile devices, use the on-screen directional buttons below the game canvas to control your snake.</p>

                    <div class="guide-tip">
                        <div class="guide-tip-title"> Pro Tip</div>
                        <p>You can't reverse direction instantly (e.g., go from left to right). This would cause you to crash into yourself!</p>
                    </div>
                </div>

                <!-- GAME MODES TAB -->
                <div class="guide-section" id="guide-modes">
                    <h3>Game Modes</h3>
                    <p>Choose your preferred way to play:</p>

                    <div class="guide-grid">
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Classic</div>
                            <div class="guide-card-desc">The original snake experience. Hit a wall or yourself and it's game over. Standard scoring.</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Time Attack</div>
                            <div class="guide-card-desc">Race against the clock! You have 60 seconds to score as many points as possible.</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">No Walls</div>
                            <div class="guide-card-desc">Walls are portals! Exit one side and appear on the opposite side. You can still die from hitting yourself.</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Zen</div>
                            <div class="guide-card-desc">Relaxing mode with no death. Perfect for practice or stress-free play. Just enjoy growing your snake!</div>
                        </div>
                    </div>
                </div>

                <!-- SETTINGS TAB -->
                <div class="guide-section" id="guide-settings">
                    <h3>Game Settings</h3>

                    <h3>Speed</h3>
                    <ul class="guide-list">
                        <li><strong>Slow</strong> Relaxed pace, great for beginners</li>
                        <li><strong>Normal</strong> Balanced difficulty (default)</li>
                        <li><strong>Fast</strong> Quick movement for experienced players</li>
                        <li><strong>Insane</strong> Extreme speed for the ultimate challenge!</li>
                    </ul>

                    <h3>Map Size</h3>
                    <ul class="guide-list">
                        <li><strong>Small</strong> Compact arena, less room to maneuver</li>
                        <li><strong>Medium</strong> Balanced play area (default)</li>
                        <li><strong>Large</strong> Spacious field, more room to grow</li>
                    </ul>

                    <h3>Obstacles</h3>
                    <p>Toggle obstacles ON to add random barriers on the map. Hitting an obstacle ends your game!</p>

                    <h3>Themes</h3>
                    <p>Change the visual style of the entire game:</p>
                    <ul class="guide-list">
                        <li><span class="guide-color-dot" style="background: #00ff88;"></span><strong>Neon</strong> Cyberpunk neon aesthetic (default)</li>
                        <li><span class="guide-color-dot" style="background: #ffcc00;"></span><strong>Retro</strong> Classic arcade vibes</li>
                        <li><span class="guide-color-dot" style="background: #00b4d8;"></span><strong>Ocean</strong> Cool blue underwater feel</li>
                        <li><span class="guide-color-dot" style="background: #80b918;"></span><strong>Forest</strong> Natural green tones</li>
                        <li><span class="guide-color-dot" style="background: #f72585;"></span><strong>Sunset</strong> Warm pink and purple gradients</li>
                    </ul>

                    <h3>Snake Skins</h3>
                    <p>Customize your snake's appearance:</p>
                    <ul class="guide-list">
                        <li><span class="guide-color-dot" style="background: #00ff88;"></span><strong>Neon</strong> Classic green glow</li>
                        <li><span class="guide-color-dot" style="background: #ff4400;"></span><strong>Fire</strong> Hot orange and red</li>
                        <li><span class="guide-color-dot" style="background: #00bfff;"></span><strong>Ice</strong> Cool blue frost</li>
                        <li><span class="guide-color-dot" style="background: #9b59b6;"></span><strong>Purple</strong> Royal purple haze</li>
                        <li><span class="guide-color-dot" style="background: #ffd700;"></span><strong>Gold</strong> Luxurious golden shine</li>
                        <li><span class="guide-color-dot" style="background: linear-gradient(90deg, red, orange, yellow, green, blue, purple);"></span><strong>Rainbow</strong> Color-shifting magic</li>
                        <li><span class="guide-color-dot" style="background: #333;"></span><strong>Stealth</strong> Dark and mysterious</li>
                        <li><span class="guide-color-dot" style="background: #ff69b4;"></span><strong>Candy</strong> Sweet pink treats</li>
                    </ul>
                </div>

                <!-- FOOD & POWER-UPS TAB -->
                <div class="guide-section" id="guide-items">
                    <h3>Food Types</h3>
                    <p>Different foods give different rewards:</p>

                    <div class="guide-grid">
                        <div class="guide-card">
                            <div class="guide-card-icon"><span class="guide-color-dot" style="background: #ff0055; width: 20px; height: 20px;"></span></div>
                            <div class="guide-card-title">Apple (60%)</div>
                            <div class="guide-card-desc">+10 points, grows by 1 segment. The most common food.</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"><span class="guide-color-dot" style="background: #ffd700; width: 20px; height: 20px;"></span></div>
                            <div class="guide-card-title">Golden Apple (10%)</div>
                            <div class="guide-card-desc">+50 points, grows by 1 segment. Rare and valuable!</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"><span class="guide-color-dot" style="background: #ff66aa; width: 20px; height: 20px;"></span></div>
                            <div class="guide-card-title">Cherry (20%)</div>
                            <div class="guide-card-desc">+20 points, grows by 2 segments. Double the growth!</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"><span class="guide-color-dot" style="background: #8b4513; width: 20px; height: 20px;"></span></div>
                            <div class="guide-card-title">Rotten Apple (10%)</div>
                            <div class="guide-card-desc">-10 points, shrinks by 1 segment. Avoid if possible!</div>
                        </div>
                    </div>

                    <h3>Power-ups</h3>
                    <p>Special items spawn every 10 seconds. Grab them for temporary abilities!</p>

                    <div class="guide-grid">
                        <div class="guide-card">
                            <div class="guide-card-icon"><span class="guide-color-dot" style="background: #00aaff; width: 20px; height: 20px;"></span></div>
                            <div class="guide-card-title">Speed Boost</div>
                            <div class="guide-card-desc">Move faster for 5 seconds. Great for quick food grabs!</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"><span class="guide-color-dot" style="background: #00ffff; width: 20px; height: 20px;"></span></div>
                            <div class="guide-card-title">Shield</div>
                            <div class="guide-card-desc">Invincibility for 5 seconds. Pass through walls and yourself!</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"><span class="guide-color-dot" style="background: #ffd700; width: 20px; height: 20px;"></span></div>
                            <div class="guide-card-title">2x Score</div>
                            <div class="guide-card-desc">Double points for 8 seconds. Maximize your eating!</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"><span class="guide-color-dot" style="background: #b400ff; width: 20px; height: 20px;"></span></div>
                            <div class="guide-card-title">Slow Motion</div>
                            <div class="guide-card-desc">Slows everything for 6 seconds. Easier navigation!</div>
                        </div>
                    </div>

                    <div class="guide-tip">
                        <div class="guide-tip-title"> Pro Tip</div>
                        <p>Active power-ups are shown at the top of the screen with a countdown timer. Combine Shield with risky maneuvers!</p>
                    </div>
                </div>

                <!-- MULTIPLAYER TAB -->
                <div class="guide-section" id="guide-multiplayer">
                    <h3>Multiplayer Mode</h3>
                    <p>Play with friends in real-time! Requires signing in with Google.</p>

                    <h3>Getting Started</h3>
                    <ul class="guide-list">
                        <li><strong>Step 1</strong> Sign in with your Google account</li>
                        <li><strong>Step 2</strong> Select 2P or 3P under "Players"</li>
                        <li><strong>Step 3</strong> Create a room or enter a room code to join</li>
                        <li><strong>Step 4</strong> Share the room code with friends</li>
                        <li><strong>Step 5</strong> Once everyone is ready, the host starts the game</li>
                    </ul>

                    <h3>How It Works</h3>
                    <div class="guide-grid">
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Create Room</div>
                            <div class="guide-card-desc">Host a game and share the generated room code with friends.</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Join Room</div>
                            <div class="guide-card-desc">Enter a friend's room code to join their game lobby.</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Lives System</div>
                            <div class="guide-card-desc">Each player has 3 lives. Lose all lives and you're eliminated!</div>
                        </div>
                        <div class="guide-card">
                            <div class="guide-card-icon"></div>
                            <div class="guide-card-title">Ghost Mode</div>
                            <div class="guide-card-desc">See other players as ghosts. You can't collide with each other.</div>
                        </div>
                    </div>

                    <div class="guide-tip">
                        <div class="guide-tip-title"> Pro Tip</div>
                        <p>The host can customize game settings (mode, speed, size, obstacles) before starting. Coordinate with your friends for the best experience!</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Help Button -->
    <button class="help-btn" id="helpBtn" title="How to Play">?</button>

    <!-- Mobile Settings Toggle -->
    <button class="mobile-settings-toggle" id="mobileSettingsToggle" title="Settings"></button>

    <!-- Mobile Settings Overlay -->
    <div class="mobile-settings-overlay" id="mobileSettingsOverlay"></div>

    <!-- Mobile Settings Panel -->
    <div class="mobile-settings-panel" id="mobileSettingsPanel">
        <h3 style="color: var(--primary); font-family: 'Orbitron', sans-serif; margin-bottom: 20px;">Settings</h3>

        <!-- Players Selection -->
        <div class="setting-group" style="margin-bottom: 15px;">
            <label class="setting-label" style="color: var(--text-secondary); font-size: 0.85rem;">Players</label>
            <div class="setting-options" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <button class="setting-btn mobile-players-btn active" data-players="1">1P</button>
                <button class="setting-btn mobile-players-btn" data-players="2">2P</button>
                <button class="setting-btn mobile-players-btn" data-players="3">3P</button>
            </div>
        </div>

        <!-- Multiplayer Controls (hidden by default) -->
        <div class="mobile-mp-controls" id="mobileMpControls" style="display: none; margin-bottom: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 1px solid var(--glass-border);">
            <button class="mobile-play-btn" id="mobileCreateRoomBtn" style="margin: 0 0 10px 0; background: linear-gradient(135deg, #ffd700, #ffaa00);">Create Room</button>
            <div style="text-align: center; color: var(--text-secondary); font-size: 0.8rem; margin: 10px 0;"> or </div>
            <input type="text" id="mobileRoomCodeInput" placeholder="Enter Room Code" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.1); color: var(--text-primary); font-size: 1rem; text-transform: uppercase; text-align: center; margin-bottom: 10px;">
            <button class="mobile-play-btn" id="mobileJoinRoomBtn" style="margin: 0; background: linear-gradient(135deg, var(--secondary), #0099cc);">Join Room</button>
        </div>

        <div class="setting-group" style="margin-bottom: 15px;">
            <label class="setting-label" style="color: var(--text-secondary); font-size: 0.85rem;">Game Mode</label>
            <div class="setting-options" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <button class="setting-btn mobile-mode-btn active" data-mode="classic">Classic</button>
                <button class="setting-btn mobile-mode-btn" data-mode="timeattack">Time</button>
                <button class="setting-btn mobile-mode-btn" data-mode="nowalls">No Walls</button>
                <button class="setting-btn mobile-mode-btn" data-mode="zen">Zen</button>
            </div>
        </div>

        <div class="setting-group" style="margin-bottom: 15px;">
            <label class="setting-label" style="color: var(--text-secondary); font-size: 0.85rem;">Speed</label>
            <div class="setting-options" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <button class="setting-btn mobile-speed-btn" data-speed="slow">Slow</button>
                <button class="setting-btn mobile-speed-btn active" data-speed="normal">Normal</button>
                <button class="setting-btn mobile-speed-btn" data-speed="fast">Fast</button>
            </div>
        </div>

        <div class="setting-group" style="margin-bottom: 15px;">
            <label class="setting-label" style="color: var(--text-secondary); font-size: 0.85rem;">Map Size</label>
            <div class="setting-options" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <button class="setting-btn mobile-size-btn" data-size="small">Small</button>
                <button class="setting-btn mobile-size-btn active" data-size="medium">Medium</button>
                <button class="setting-btn mobile-size-btn" data-size="large">Large</button>
            </div>
        </div>

        <div class="setting-group" style="margin-bottom: 15px;">
            <label class="setting-label" style="color: var(--text-secondary); font-size: 0.85rem;">Theme</label>
            <div class="setting-options" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <button class="setting-btn mobile-theme-btn active" data-theme="neon" style="background: #00ff88; color: #000;">Neon</button>
                <button class="setting-btn mobile-theme-btn" data-theme="retro" style="background: #ffcc00; color: #000;">Retro</button>
                <button class="setting-btn mobile-theme-btn" data-theme="ocean" style="background: #00b4d8; color: #000;">Ocean</button>
                <button class="setting-btn mobile-theme-btn" data-theme="forest" style="background: #80b918; color: #000;">Forest</button>
                <button class="setting-btn mobile-theme-btn" data-theme="sunset" style="background: #f72585; color: #fff;">Sunset</button>
            </div>
        </div>

        <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px 0; border-top: 1px solid var(--glass-border); margin-top: 10px;">
            <span style="color: var(--text-secondary); font-size: 0.85rem;">Obstacles</span>
            <label class="mobile-toggle" style="position: relative; display: inline-block; width: 50px; height: 28px; cursor: pointer;">
                <input type="checkbox" id="mobileObstaclesToggle" style="opacity: 0; width: 0; height: 0; position: absolute;">
                <span class="mobile-toggle-slider" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.2); border-radius: 28px; transition: 0.3s;"></span>
                <span class="mobile-toggle-knob" style="position: absolute; top: 3px; left: 3px; width: 22px; height: 22px; background: #fff; border-radius: 50%; transition: 0.3s; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></span>
            </label>
        </div>

        <button class="mobile-play-btn" id="mobilePlayBtn" style="margin-top: 20px;"> START GAME</button>

        <!-- Mobile Leaderboard -->
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--glass-border);">
            <h4 style="color: var(--primary); font-family: 'Orbitron', sans-serif; font-size: 0.9rem; margin: 0 0 10px 0; display: flex; align-items: center; gap: 8px;">
                 Global Leaderboard
            </h4>
            <ul class="mobile-leaderboard-list" id="mobileLeaderboardList" style="list-style: none; padding: 0; margin: 0; max-height: 200px; overflow-y: auto;">
                <li style="color: var(--text-secondary); font-size: 0.85rem; padding: 8px; text-align: center;">Loading...</li>
            </ul>
        </div>
    </div>

    <!-- Background Effects -->
    <div class="scan-lines"></div>
    <div class="bg-orb bg-orb-1"></div>
    <div class="bg-orb bg-orb-2"></div>
    <div class="bg-orb bg-orb-3"></div>

    <div class="main-container">
        <div class="left-panel">
            <div class="leaderboard">
                <h2>Global Leaderboard</h2>
                <ul class="leaderboard-list" id="leaderboardList">
                    <li class="loading">Loading...</li>
                </ul>
            </div>
        </div>

        <div class="game-container">
            <div class="header">
                <h1>SNAKE</h1>
                <div id="authContainer">
                    <button class="auth-btn" id="signInBtn" onclick="signIn()">
                        <svg class="google-icon" viewBox="0 0 24 24">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        Sign in with Google
                    </button>
                </div>
            </div>
            <div class="score-board">
                <div class="score">Score: <span id="score">0</span></div>
                <div class="timer" id="timerDisplay" style="display: none;">Time: <span id="timer">60</span>s</div>
                <div class="high-score" id="highScoreDisplay">Your Best: <span id="highScore">0</span></div>
                <div class="mp-live-scores" id="mpLiveScores" style="display: none;"></div>
            </div>
            <div class="mode-indicator" id="modeIndicator"></div>
            <div class="combo-display" id="comboDisplay"></div>
            <div class="active-powerups" id="activePowerups"></div>
            <div class="canvas-area">
                <div class="canvas-wrapper">
                    <canvas id="gameCanvas" width="400" height="400"></canvas>
                </div>
            </div>
            <div class="game-over" id="gameOver">
                <div class="game-over-content">
                    <h2>Game Over!</h2>
                    <p>Final Score: <span id="finalScore">0</span></p>
                    <p class="new-record" id="newRecord" style="display: none;">New Personal Best!</p>
                    <button class="restart-btn" id="restartBtn">Play Again</button>
                </div>
            </div>
            <div class="controls">
                <p>Use Arrow Keys or WASD to move</p>
                <p>Press Space to pause | Press F for fullscreen</p>
                <button class="fullscreen-btn" id="fullscreenBtn" onclick="toggleFullscreen()">
                    <svg id="fullscreenIcon" viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
                        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                    </svg>
                    Fullscreen
                </button>
            </div>
            <div class="mobile-controls" id="mobileControls">
                <div class="mobile-dpad">
                    <div class="dpad-row">
                        <button class="mobile-btn" id="upBtn"></button>
                    </div>
                    <div class="dpad-row">
                        <button class="mobile-btn" id="leftBtn"></button>
                        <button class="mobile-btn mobile-pause-btn" id="mobilePauseBtn"></button>
                        <button class="mobile-btn" id="rightBtn"></button>
                    </div>
                    <div class="dpad-row">
                        <button class="mobile-btn" id="downBtn"></button>
                    </div>
                </div>
            </div>
        </div>

        <div class="side-panel">
            <div class="settings">
                <h2>Settings</h2>

                <div class="setting-group">
                    <label class="setting-label">Players</label>
                    <div class="setting-options player-count-options">
                        <button class="setting-btn active" data-players="1">1P</button>
                        <button class="setting-btn" data-players="2">2P</button>
                        <button class="setting-btn" data-players="3">3P</button>
                    </div>
                </div>

                <div class="multiplayer-controls" id="multiplayerControls" style="display: none;">
                    <div class="mp-section">
                        <button class="mp-btn create-room-btn" id="createRoomBtn">Create Room</button>
                        <div class="mp-divider">or</div>
                        <div class="mp-join-section">
                            <input type="text" id="roomCodeInput" placeholder="Enter Room Code" class="room-code-input">
                            <button class="mp-btn join-room-btn" id="joinRoomBtn">Join</button>
                        </div>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Game Mode</label>
                    <div class="setting-options mode-options">
                        <button class="setting-btn active" data-mode="classic" title="Standard snake game">Classic</button>
                        <button class="setting-btn" data-mode="timeattack" title="60 seconds to get highest score">Time Attack</button>
                        <button class="setting-btn" data-mode="nowalls" title="Pass through walls">No Walls</button>
                        <button class="setting-btn" data-mode="zen" title="Relaxing mode, no death">Zen</button>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Speed</label>
                    <div class="setting-options">
                        <button class="setting-btn" data-speed="slow">Slow</button>
                        <button class="setting-btn active" data-speed="normal">Normal</button>
                        <button class="setting-btn" data-speed="fast">Fast</button>
                        <button class="setting-btn" data-speed="insane">Insane</button>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Map Size</label>
                    <div class="setting-options">
                        <button class="setting-btn" data-size="small">Small</button>
                        <button class="setting-btn active" data-size="medium">Medium</button>
                        <button class="setting-btn" data-size="large">Large</button>
                    </div>
                </div>

                <div class="setting-group">
                    <div class="toggle-container">
                        <label class="setting-label" style="margin-bottom: 0;">Obstacles</label>
                        <div class="toggle" id="obstaclesToggle"></div>
                    </div>
                </div>

                <div class="setting-group">
                    <div class="toggle-container">
                        <label class="setting-label" style="margin-bottom: 0;">Sound Effects</label>
                        <div class="toggle active" id="soundToggle"></div>
                    </div>
                </div>

                <button class="apply-btn" id="applySettings">Apply & Restart</button>
                <p class="settings-note">Changes require game restart</p>

                <div class="setting-group">
                    <label class="setting-label">Game Theme</label>
                    <div class="theme-selector">
                        <button class="theme-btn active" data-theme="neon" title="Neon Cyberpunk">
                            <div class="theme-preview neon-preview">
                                <div class="theme-preview-grid"></div>
                                <div class="theme-preview-snake"></div>
                            </div>
                            <span class="theme-name">Neon</span>
                        </button>
                        <button class="theme-btn" data-theme="retro" title="Retro Arcade">
                            <div class="theme-preview retro-preview">
                                <div class="theme-preview-grid"></div>
                                <div class="theme-preview-snake"></div>
                            </div>
                            <span class="theme-name">Retro</span>
                        </button>
                        <button class="theme-btn" data-theme="ocean" title="Ocean Blue">
                            <div class="theme-preview ocean-preview">
                                <div class="theme-preview-grid"></div>
                                <div class="theme-preview-snake"></div>
                            </div>
                            <span class="theme-name">Ocean</span>
                        </button>
                        <button class="theme-btn" data-theme="forest" title="Nature Forest">
                            <div class="theme-preview forest-preview">
                                <div class="theme-preview-grid"></div>
                                <div class="theme-preview-snake"></div>
                            </div>
                            <span class="theme-name">Forest</span>
                        </button>
                        <button class="theme-btn" data-theme="sunset" title="Sunset Warm">
                            <div class="theme-preview sunset-preview">
                                <div class="theme-preview-grid"></div>
                                <div class="theme-preview-snake"></div>
                            </div>
                            <span class="theme-name">Sunset</span>
                        </button>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Snake Skin</label>
                    <div class="skin-options">
                        <button class="skin-btn active" data-skin="neon" title="Neon Green">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #00ff88, #00cc6a)"></span>
                        </button>
                        <button class="skin-btn" data-skin="fire" title="Fire">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #ff4400, #ffaa00)"></span>
                        </button>
                        <button class="skin-btn" data-skin="ice" title="Ice">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #00bfff, #e0ffff)"></span>
                        </button>
                        <button class="skin-btn" data-skin="purple" title="Purple Haze">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #9b59b6, #e056fd)"></span>
                        </button>
                        <button class="skin-btn" data-skin="gold" title="Golden">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #ffd700, #ffec8b)"></span>
                        </button>
                        <button class="skin-btn" data-skin="rainbow" title="Rainbow">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #8b00ff)"></span>
                        </button>
                        <button class="skin-btn" data-skin="stealth" title="Stealth">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #2c3e50, #34495e)"></span>
                        </button>
                        <button class="skin-btn" data-skin="candy" title="Candy">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #ff69b4, #ff1493)"></span>
                        </button>
                    </div>
                </div>

                <div class="powerup-legend">
                    <h3>Food Types</h3>
                    <div class="legend-item"><span class="legend-dot" style="background:#ff0055"></span> Apple (+10 pts)</div>
                    <div class="legend-item"><span class="legend-dot" style="background:#ffd700"></span> Golden (+50 pts)</div>
                    <div class="legend-item"><span class="legend-dot" style="background:#ff66aa"></span> Cherry (+20, grow x2)</div>
                    <div class="legend-item"><span class="legend-dot" style="background:#8b4513"></span> Rotten (-10, shrink)</div>
                </div>

                <div class="powerup-legend">
                    <h3>Power-ups</h3>
                    <div class="legend-item"><span class="legend-dot speed"></span> Speed Boost</div>
                    <div class="legend-item"><span class="legend-dot shield"></span> Shield (Invincible)</div>
                    <div class="legend-item"><span class="legend-dot double"></span> 2x Score</div>
                    <div class="legend-item"><span class="legend-dot slow"></span> Slow Motion</div>
                </div>
            </div>

            <div class="daily-challenge">
                <h2>Daily Challenge</h2>
                <div class="challenge-content" id="challengeContent">
                    <div class="challenge-desc" id="challengeDesc"></div>
                    <div class="challenge-progress">
                        <div class="challenge-bar">
                            <div class="challenge-bar-fill" id="challengeBarFill"></div>
                        </div>
                        <span class="challenge-status" id="challengeStatus"></span>
                    </div>
                    <div class="challenge-reward" id="challengeReward"></div>
                </div>
            </div>

        </div>
    </div>

    <!-- Username Modal -->
    <div class="username-modal" id="usernameModal">
        <div class="username-modal-content">
            <h2>Set Your Username</h2>
            <p>Choose a display name for the leaderboard</p>
            <input type="text" id="usernameInput" placeholder="Enter username" maxlength="20">
            <div class="username-modal-buttons">
                <button class="username-btn cancel" id="usernameCancel">Cancel</button>
                <button class="username-btn save" id="usernameSave">Save</button>
            </div>
        </div>
    </div>

    <!-- Multiplayer Lobby Modal -->
    <div class="mp-lobby-modal" id="mpLobbyModal">
        <div class="mp-lobby-content">
            <div class="mp-lobby-header">
                <h2>Multiplayer Lobby</h2>
                <button class="mp-lobby-close" id="mpLobbyClose">&times;</button>
            </div>

            <div class="mp-room-code-section">
                <label>Room Code</label>
                <div class="mp-room-code-display">
                    <span id="roomCodeDisplay">------</span>
                    <button class="mp-copy-btn" id="copyRoomCode" title="Copy room code">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                    <button class="mp-copy-btn" id="copyRoomLink" title="Copy invite link">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="mp-game-settings" id="mpGameSettings">
                <div class="mp-setting-badge"><span id="lobbyMode">Classic</span></div>
                <div class="mp-setting-badge"><span id="lobbySpeed">Normal</span></div>
                <div class="mp-setting-badge"><span id="lobbySize">Medium</span></div>
                <div class="mp-setting-badge"><span id="lobbyObstacles">No Obstacles</span></div>
            </div>

            <!-- Host Settings (only shown to host) -->
            <div class="mp-host-settings" id="mpHostSettings" style="display: none;">
                <div class="mp-setting-group">
                    <label>Game Mode</label>
                    <div class="mp-setting-buttons" id="mpModeButtons">
                        <button class="mp-setting-btn active" data-mp-mode="classic">Classic</button>
                        <button class="mp-setting-btn" data-mp-mode="speed">Speed</button>
                        <button class="mp-setting-btn" data-mp-mode="zen">Zen</button>
                        <button class="mp-setting-btn" data-mp-mode="time">Time Attack</button>
                    </div>
                </div>
                <div class="mp-setting-group">
                    <label>Speed</label>
                    <div class="mp-setting-buttons" id="mpSpeedButtons">
                        <button class="mp-setting-btn" data-mp-speed="slow">Slow</button>
                        <button class="mp-setting-btn active" data-mp-speed="normal">Normal</button>
                        <button class="mp-setting-btn" data-mp-speed="fast">Fast</button>
                        <button class="mp-setting-btn" data-mp-speed="insane">Insane</button>
                    </div>
                </div>
                <div class="mp-setting-group">
                    <label>Map Size</label>
                    <div class="mp-setting-buttons" id="mpSizeButtons">
                        <button class="mp-setting-btn" data-mp-size="small">Small</button>
                        <button class="mp-setting-btn active" data-mp-size="medium">Medium</button>
                        <button class="mp-setting-btn" data-mp-size="large">Large</button>
                    </div>
                </div>
                <div class="mp-setting-group">
                    <label>Obstacles</label>
                    <div class="mp-setting-buttons" id="mpObstaclesButtons">
                        <button class="mp-setting-btn active" data-mp-obstacles="false">Off</button>
                        <button class="mp-setting-btn" data-mp-obstacles="true">On</button>
                    </div>
                </div>
            </div>

            <div class="mp-players-section">
                <label>Players (<span id="playerCountDisplay">1</span>/<span id="maxPlayersDisplay">2</span>)</label>
                <div class="mp-players-list" id="mpPlayersList">
                    <!-- Players will be added dynamically -->
                </div>
            </div>

            <div class="mp-lobby-actions">
                <button class="mp-btn mp-ready-btn" id="mpReadyBtn">Ready</button>
                <button class="mp-btn mp-start-btn" id="mpStartBtn" style="display: none;">Start Game</button>
                <button class="mp-btn mp-leave-btn" id="mpLeaveBtn">Leave Room</button>
            </div>

            <div class="mp-lobby-status" id="mpLobbyStatus">Waiting for players...</div>
        </div>
    </div>

    <!-- Multiplayer HUD (shown during game) -->
    <div class="mp-hud" id="mpHud" style="display: none;">
        <div class="mp-lives-display" id="mpLivesDisplay">
            <!-- Lives hearts will be added dynamically -->
        </div>
        <div class="mp-scores-display" id="mpScoresDisplay">
            <!-- Player scores will be added dynamically -->
        </div>
    </div>

    <!-- Multiplayer Results Modal -->
    <div class="mp-results-modal" id="mpResultsModal">
        <div class="mp-results-content">
            <h2>Game Over!</h2>
            <div class="mp-results-winner" id="mpResultsWinner">
                <!-- Winner display -->
            </div>
            <div class="mp-results-rankings" id="mpResultsRankings">
                <!-- Rankings list -->
            </div>
            <div class="mp-results-actions">
                <button class="mp-btn" id="mpPlayAgain">Play Again</button>
                <button class="mp-btn mp-leave-btn" id="mpExitResults">Exit</button>
            </div>
        </div>
    </div>

    <!-- Achievement Popup -->
    <div class="achievement-popup" id="achievementPopup">
        <div class="achievement-icon"></div>
        <div class="achievement-info">
            <div class="achievement-title">Achievement Unlocked!</div>
            <div class="achievement-name" id="achievementName"></div>
        </div>
    </div>

    <!-- Achievements Panel (toggleable) -->
    <button class="achievements-toggle" id="achievementsToggle"></button>
    <div class="achievements-panel" id="achievementsPanel">
        <div class="achievements-header">
            <h3>Achievements</h3>
            <span class="achievements-close" id="achievementsClose">&times;</span>
        </div>
        <div class="achievements-list" id="achievementsList"></div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, where, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";
        import { getDatabase, ref, set, get, onValue, update as dbUpdate, remove, push, child, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js";

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyBX1h3arCxEBsX3hlYJKDK6k2grnJkru1I",
            authDomain: "snake-3e4dc.firebaseapp.com",
            projectId: "snake-3e4dc",
            storageBucket: "snake-3e4dc.firebasestorage.app",
            messagingSenderId: "503723147324",
            appId: "1:503723147324:web:46ba9ef5f034c831904339",
            databaseURL: "https://snake-3e4dc-default-rtdb.firebaseio.com"
        };

        // Initialize Firebase
        let app, auth, db, rtdb, provider;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            provider = new GoogleAuthProvider();
            try {
                rtdb = getDatabase(app);
            } catch (e) {
                console.warn('Realtime Database not available:', e);
                rtdb = null;
            }
        } catch (e) {
            console.error('Firebase initialization failed:', e);
        }

        // Game elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const mpLiveScores = document.getElementById('mpLiveScores');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const newRecordEl = document.getElementById('newRecord');
        const authContainer = document.getElementById('authContainer');
        const leaderboardList = document.getElementById('leaderboardList');
        const activePowerupsEl = document.getElementById('activePowerups');
        const usernameModal = document.getElementById('usernameModal');
        const usernameInput = document.getElementById('usernameInput');
        const usernameSaveBtn = document.getElementById('usernameSave');
        const usernameCancelBtn = document.getElementById('usernameCancel');

        // Custom username
        let customUsername = null;

        // Settings
        const speedSettings = { slow: 150, normal: 100, fast: 60, insane: 35 };
        const sizeSettings = { small: { tiles: 15, pixels: 300 }, medium: { tiles: 20, pixels: 400 }, large: { tiles: 25, pixels: 500 } };

        let currentSpeed = 'normal';
        let currentSize = 'medium';
        let obstaclesEnabled = false;
        let obstacles = [];
        let currentSkin = 'neon';
        let currentMode = 'classic';
        let timeLeft = 60;
        let timerInterval = null;

        // Multiplayer state
        let isMultiplayer = false;
        let playerCount = 1; // 1, 2, or 3
        let currentGameId = null;
        let isHost = false;
        let playerLives = 3;
        let isSpectating = false;
        let otherPlayers = {}; // {playerId: {snake, score, lives, color, name, alive}}
        let gameStateListener = null;
        let syncInterval = null;
        let myPlayerColor = '#00ff88';
        const PLAYER_COLORS = ['#00ff88', '#ff4488', '#44aaff', '#ffaa00'];
        const SYNC_RATE = 100; // ~10 updates per second (reduced for performance)

        // Game modes configuration
        const GAME_MODES = {
            classic: {
                name: 'Classic',
                description: 'Standard snake game',
                hasTimer: false,
                noWalls: false,
                noDeath: false
            },
            timeattack: {
                name: 'Time Attack',
                description: '60 seconds to score!',
                hasTimer: true,
                timerDuration: 60,
                noWalls: false,
                noDeath: false
            },
            nowalls: {
                name: 'No Walls',
                description: 'Pass through walls',
                hasTimer: false,
                noWalls: true,
                noDeath: false
            },
            zen: {
                name: 'Zen Mode',
                description: 'Relax, no death',
                hasTimer: false,
                noWalls: true,
                noDeath: true
            }
        };

        // Snake skins configuration
        const SNAKE_SKINS = {
            neon: {
                primary: '#00ff88',
                secondary: '#00cc6a',
                glow: '#00ff88',
                eye: '#1a1a2e'
            },
            fire: {
                primary: '#ff4400',
                secondary: '#ffaa00',
                glow: '#ff6600',
                eye: '#1a1a2e'
            },
            ice: {
                primary: '#00bfff',
                secondary: '#e0ffff',
                glow: '#00d4ff',
                eye: '#1a1a2e'
            },
            purple: {
                primary: '#9b59b6',
                secondary: '#e056fd',
                glow: '#b866e0',
                eye: '#1a1a2e'
            },
            gold: {
                primary: '#ffd700',
                secondary: '#ffec8b',
                glow: '#ffdf00',
                eye: '#1a1a2e'
            },
            rainbow: {
                primary: 'rainbow', // Special flag for rainbow effect
                secondary: 'rainbow',
                glow: '#ffffff',
                eye: '#1a1a2e'
            },
            stealth: {
                primary: '#2c3e50',
                secondary: '#34495e',
                glow: '#3d566e',
                eye: '#00ff88'
            },
            candy: {
                primary: '#ff69b4',
                secondary: '#ff1493',
                glow: '#ff69b4',
                eye: '#1a1a2e'
            }
        };

        // Game variables
        let gridSize = 20;
        let tileCount = 20;
        let snake = [];
        let food = {};
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let score = 0;
        let personalBest = 0;
        let gameLoop;
        let isPaused = false;
        let gameSpeed = 100;
        let baseSpeed = 100;
        let currentUser = null;

        // Food types system
        const FOOD_TYPES = {
            apple: { color: '#ff0055', points: 10, grow: 1, chance: 60 },
            golden: { color: '#ffd700', points: 50, grow: 1, chance: 10 },
            cherry: { color: '#ff66aa', points: 20, grow: 2, chance: 20 },
            rotten: { color: '#8b4513', points: -10, grow: -1, chance: 10 }
        };

        // Power-up system
        const POWERUP_TYPES = {
            speed: { color: '#00aaff', name: 'Speed Boost', duration: 5000 },
            shield: { color: '#00ffff', name: 'Shield', duration: 5000 },
            double: { color: '#ffd700', name: '2x Score', duration: 8000 },
            slow: { color: '#b400ff', name: 'Slow Motion', duration: 6000 }
        };

        let powerup = null;
        let activePowerups = {
            speed: { active: false, endTime: 0 },
            shield: { active: false, endTime: 0 },
            double: { active: false, endTime: 0 },
            slow: { active: false, endTime: 0 }
        };

        let scoreMultiplier = 1;
        let lastPowerupSpawn = 0;
        const POWERUP_SPAWN_INTERVAL = 10000; // Spawn every 10 seconds

        // Achievements System
        const ACHIEVEMENTS = {
            first_food: { name: 'First Bite', desc: 'Eat your first food', icon: '' },
            score_50: { name: 'Getting Started', desc: 'Score 50 points', icon: '' },
            score_100: { name: 'Century', desc: 'Score 100 points', icon: '' },
            score_250: { name: 'Quarter Master', desc: 'Score 250 points', icon: '' },
            score_500: { name: 'Half Grand', desc: 'Score 500 points', icon: '' },
            score_1000: { name: 'Grand Master', desc: 'Score 1000 points', icon: '' },
            length_10: { name: 'Growing Up', desc: 'Reach length 10', icon: '' },
            length_20: { name: 'Long Boi', desc: 'Reach length 20', icon: '' },
            length_50: { name: 'Mega Snake', desc: 'Reach length 50', icon: '' },
            golden_catch: { name: 'Gold Digger', desc: 'Eat a golden apple', icon: '' },
            powerup_collect: { name: 'Powered Up', desc: 'Collect a power-up', icon: '' },
            survive_60: { name: 'Survivor', desc: 'Survive 60 seconds', icon: '' },
            no_walls: { name: 'Wall Walker', desc: 'Play No Walls mode', icon: '' },
            time_attack: { name: 'Speed Demon', desc: 'Play Time Attack mode', icon: '' },
            zen_master: { name: 'Zen Master', desc: 'Play Zen mode', icon: '' },
            skin_change: { name: 'Fashionista', desc: 'Change your skin', icon: '' }
        };

        let unlockedAchievements = JSON.parse(localStorage.getItem('snakeAchievements') || '[]');
        let gameStartTime = Date.now();
        let totalFoodEaten = 0;
        let achievementQueue = [];
        let showingAchievement = false;

        // Combo System
        let combo = 0;
        let lastFoodTime = 0;
        const COMBO_TIMEOUT = 3000; // 3 seconds to maintain combo
        const COMBO_MULTIPLIERS = [1, 1.2, 1.5, 2, 2.5, 3]; // Multipliers for combo levels

        function updateComboDisplay() {
            const comboDisplay = document.getElementById('comboDisplay');
            const timeSinceFood = Date.now() - lastFoodTime;
            const timeRemaining = Math.max(0, COMBO_TIMEOUT - timeSinceFood);

            if (combo > 0 && timeRemaining > 0) {
                const comboLevel = Math.min(combo, 5);
                const multiplier = COMBO_MULTIPLIERS[Math.min(combo, COMBO_MULTIPLIERS.length - 1)];
                comboDisplay.innerHTML = `
                    <span class="combo-text combo-${comboLevel}">
                        ${combo}x COMBO! (${multiplier}x points)
                    </span>
                    <div class="combo-bar">
                        <div class="combo-bar-fill" style="width: ${(timeRemaining / COMBO_TIMEOUT) * 100}%"></div>
                    </div>
                `;
            } else if (combo > 0 && timeRemaining <= 0) {
                combo = 0;
                comboDisplay.innerHTML = '';
            } else {
                comboDisplay.innerHTML = '';
            }
        }

        function addCombo() {
            const now = Date.now();
            if (now - lastFoodTime <= COMBO_TIMEOUT) {
                combo++;
            } else {
                combo = 1;
            }
            lastFoodTime = now;
            return COMBO_MULTIPLIERS[Math.min(combo, COMBO_MULTIPLIERS.length - 1)];
        }

        // Daily Challenge System
        const DAILY_CHALLENGES = [
            { type: 'score', target: 100, desc: 'Score 100 points' },
            { type: 'score', target: 200, desc: 'Score 200 points' },
            { type: 'score', target: 300, desc: 'Score 300 points' },
            { type: 'length', target: 15, desc: 'Reach length 15' },
            { type: 'length', target: 20, desc: 'Reach length 20' },
            { type: 'combo', target: 5, desc: 'Get a 5x combo' },
            { type: 'golden', target: 3, desc: 'Eat 3 golden apples' },
            { type: 'food', target: 20, desc: 'Eat 20 pieces of food' },
            { type: 'timeattack', target: 150, desc: 'Score 150 in Time Attack' },
            { type: 'nowalls', target: 100, desc: 'Score 100 in No Walls mode' }
        ];

        let dailyChallenge = null;
        let dailyChallengeProgress = 0;
        let dailyChallengeCompleted = false;
        let dailyStreak = parseInt(localStorage.getItem('dailyStreak') || '0');
        let goldenEatenToday = 0;

        function getDailyChallenge() {
            const today = new Date().toDateString();
            const storedDate = localStorage.getItem('dailyChallengeDate');

            if (storedDate !== today) {
                // New day, generate new challenge
                const seed = hashCode(today);
                const challengeIndex = Math.abs(seed) % DAILY_CHALLENGES.length;
                dailyChallenge = DAILY_CHALLENGES[challengeIndex];
                dailyChallengeProgress = 0;
                dailyChallengeCompleted = false;
                goldenEatenToday = 0;

                localStorage.setItem('dailyChallengeDate', today);
                localStorage.setItem('dailyChallengeIndex', challengeIndex);
                localStorage.setItem('dailyChallengeCompleted', 'false');
            } else {
                // Same day, restore challenge
                const challengeIndex = parseInt(localStorage.getItem('dailyChallengeIndex') || '0');
                dailyChallenge = DAILY_CHALLENGES[challengeIndex];
                dailyChallengeCompleted = localStorage.getItem('dailyChallengeCompleted') === 'true';
            }

            updateDailyChallengeDisplay();
        }

        function hashCode(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash;
        }

        function updateDailyChallengeProgress(type, value) {
            if (dailyChallengeCompleted || !dailyChallenge) return;

            if (dailyChallenge.type === type) {
                if (type === 'combo' || type === 'golden') {
                    dailyChallengeProgress = Math.max(dailyChallengeProgress, value);
                } else {
                    dailyChallengeProgress = value;
                }

                if (dailyChallengeProgress >= dailyChallenge.target) {
                    completeDailyChallenge();
                }

                updateDailyChallengeDisplay();
            }

            // Special handling for mode-specific challenges
            if ((dailyChallenge.type === 'timeattack' && currentMode === 'timeattack' && type === 'score') ||
                (dailyChallenge.type === 'nowalls' && currentMode === 'nowalls' && type === 'score')) {
                dailyChallengeProgress = value;
                if (dailyChallengeProgress >= dailyChallenge.target) {
                    completeDailyChallenge();
                }
                updateDailyChallengeDisplay();
            }
        }

        function completeDailyChallenge() {
            if (dailyChallengeCompleted) return;

            dailyChallengeCompleted = true;
            localStorage.setItem('dailyChallengeCompleted', 'true');

            // Update streak
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const lastCompletion = localStorage.getItem('lastChallengeCompletion');

            if (lastCompletion === yesterday.toDateString()) {
                dailyStreak++;
            } else if (lastCompletion !== new Date().toDateString()) {
                dailyStreak = 1;
            }

            localStorage.setItem('dailyStreak', dailyStreak);
            localStorage.setItem('lastChallengeCompletion', new Date().toDateString());

            // Show achievement-style popup
            showAchievementPopup('daily_complete');
            updateDailyChallengeDisplay();
        }

        function updateDailyChallengeDisplay() {
            if (!dailyChallenge) return;

            const descEl = document.getElementById('challengeDesc');
            const barFill = document.getElementById('challengeBarFill');
            const statusEl = document.getElementById('challengeStatus');
            const rewardEl = document.getElementById('challengeReward');

            descEl.innerHTML = `<span class="challenge-type">${dailyChallenge.desc}</span>`;

            const progress = Math.min(dailyChallengeProgress / dailyChallenge.target * 100, 100);
            barFill.style.width = `${progress}%`;

            if (dailyChallengeCompleted) {
                statusEl.textContent = ' Completed!';
                statusEl.className = 'challenge-status completed';
            } else {
                statusEl.textContent = `${dailyChallengeProgress} / ${dailyChallenge.target}`;
                statusEl.className = 'challenge-status';
            }

            rewardEl.innerHTML = dailyStreak > 0
                ? ` <span class="streak">${dailyStreak} day streak!</span>`
                : 'Complete for streak bonus!';
        }

        // Add daily_complete to achievements
        ACHIEVEMENTS.daily_complete = { name: 'Daily Grind', desc: 'Complete a daily challenge', icon: '' };

        // Initialize daily challenge
        getDailyChallenge();

        function checkAchievement(id) {
            if (unlockedAchievements.includes(id)) return false;
            unlockedAchievements.push(id);
            localStorage.setItem('snakeAchievements', JSON.stringify(unlockedAchievements));
            showAchievementPopup(id);
            updateAchievementsList();
            return true;
        }

        function showAchievementPopup(id) {
            achievementQueue.push(id);
            processAchievementQueue();
        }

        function processAchievementQueue() {
            if (showingAchievement || achievementQueue.length === 0) return;

            showingAchievement = true;
            const id = achievementQueue.shift();
            const achievement = ACHIEVEMENTS[id];
            const popup = document.getElementById('achievementPopup');
            const nameEl = document.getElementById('achievementName');

            nameEl.textContent = achievement.name;
            document.querySelector('.achievement-icon').textContent = achievement.icon;
            popup.classList.add('show');

            setTimeout(() => {
                popup.classList.remove('show');
                setTimeout(() => {
                    showingAchievement = false;
                    processAchievementQueue();
                }, 500);
            }, 3000);
        }

        function updateAchievementsList() {
            const list = document.getElementById('achievementsList');
            list.innerHTML = '';

            const unlockedCount = unlockedAchievements.length;
            const totalCount = Object.keys(ACHIEVEMENTS).length;

            for (const [id, achievement] of Object.entries(ACHIEVEMENTS)) {
                const unlocked = unlockedAchievements.includes(id);
                list.innerHTML += `
                    <div class="achievement-item ${unlocked ? 'unlocked' : 'locked'}">
                        <div class="achievement-item-icon">${achievement.icon}</div>
                        <div class="achievement-item-info">
                            <div class="achievement-item-name">${achievement.name}</div>
                            <div class="achievement-item-desc">${achievement.desc}</div>
                        </div>
                        ${unlocked ? '<div class="achievement-item-status"></div>' : ''}
                    </div>
                `;
            }

            // Update toggle button to show count
            document.getElementById('achievementsToggle').title = `${unlockedCount}/${totalCount} Achievements`;
        }

        // Achievement panel toggle
        document.getElementById('achievementsToggle').addEventListener('click', () => {
            document.getElementById('achievementsPanel').classList.toggle('show');
        });

        document.getElementById('achievementsClose').addEventListener('click', () => {
            document.getElementById('achievementsPanel').classList.remove('show');
        });

        // Initialize achievements list
        updateAchievementsList();

        // Color helper functions
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function lerpColor(color1, color2, ratio) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);
            const r = Math.round(r1 + (r2 - r1) * ratio);
            const g = Math.round(g1 + (g2 - g1) * ratio);
            const b = Math.round(b1 + (b2 - b1) * ratio);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Draw ghost players (other players in multiplayer)
        function drawGhostPlayers() {
            Object.entries(otherPlayers).forEach(([playerId, playerData]) => {
                if (!playerData.snake || playerData.snake.length === 0) return;
                if (playerData.lives <= 0) return; // Don't draw eliminated players

                const ghostAlpha = 0.4; // Ghost transparency
                const playerColor = playerData.color || '#ff4488';

                // Draw ghost snake
                playerData.snake.forEach((segment, index) => {
                    const alpha = ghostAlpha * (1 - (index / playerData.snake.length) * 0.5);
                    ctx.fillStyle = hexToRgba(playerColor, alpha);
                    ctx.shadowColor = playerColor;
                    ctx.shadowBlur = index === 0 ? 8 : 4;

                    ctx.beginPath();
                    ctx.roundRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2,
                        5
                    );
                    ctx.fill();
                });
                ctx.shadowBlur = 0;

                // Draw eyes for ghost snake head
                if (playerData.snake.length > 0) {
                    const head = playerData.snake[0];
                    const dir = playerData.direction || { x: 1, y: 0 };
                    ctx.fillStyle = `rgba(0, 0, 0, ${ghostAlpha})`;

                    let eye1X, eye1Y, eye2X, eye2Y;
                    const eyeOffset = gridSize * 0.3;
                    const eyeSize = gridSize * 0.12;

                    if (dir.x === 1) {
                        eye1X = head.x * gridSize + gridSize - eyeOffset;
                        eye1Y = head.y * gridSize + eyeOffset;
                        eye2X = head.x * gridSize + gridSize - eyeOffset;
                        eye2Y = head.y * gridSize + gridSize - eyeOffset;
                    } else if (dir.x === -1) {
                        eye1X = head.x * gridSize + eyeOffset;
                        eye1Y = head.y * gridSize + eyeOffset;
                        eye2X = head.x * gridSize + eyeOffset;
                        eye2Y = head.y * gridSize + gridSize - eyeOffset;
                    } else if (dir.y === -1) {
                        eye1X = head.x * gridSize + eyeOffset;
                        eye1Y = head.y * gridSize + eyeOffset;
                        eye2X = head.x * gridSize + gridSize - eyeOffset;
                        eye2Y = head.y * gridSize + eyeOffset;
                    } else {
                        eye1X = head.x * gridSize + eyeOffset;
                        eye1Y = head.y * gridSize + gridSize - eyeOffset;
                        eye2X = head.x * gridSize + gridSize - eyeOffset;
                        eye2Y = head.y * gridSize + gridSize - eyeOffset;
                    }

                    ctx.beginPath();
                    ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw player name above head
                if (playerData.snake.length > 0) {
                    const head = playerData.snake[0];
                    ctx.font = '10px Inter, sans-serif';
                    ctx.fillStyle = `rgba(255, 255, 255, ${ghostAlpha + 0.2})`;
                    ctx.textAlign = 'center';
                    ctx.fillText(
                        playerData.name || 'Player',
                        head.x * gridSize + gridSize / 2,
                        head.y * gridSize - 5
                    );
                }
            });
        }

        // Sound System
        let soundEnabled = true;
        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playSound(type) {
            if (!soundEnabled || !audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const now = audioContext.currentTime;

            switch(type) {
                case 'eat':
                    // Short pleasant blip
                    oscillator.frequency.setValueAtTime(600, now);
                    oscillator.frequency.exponentialRampToValueAtTime(900, now + 0.1);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case 'powerup':
                    // Ascending magical sound
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    oscillator.start(now);
                    oscillator.stop(now + 0.3);
                    break;

                case 'death':
                    // Descending sad sound
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.4);
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    oscillator.start(now);
                    oscillator.stop(now + 0.4);
                    break;

                case 'highscore':
                    // Victory fanfare
                    const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                    notes.forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.setValueAtTime(freq, now + i * 0.15);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, now + i * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.2);
                        osc.start(now + i * 0.15);
                        osc.stop(now + i * 0.15 + 0.2);
                    });
                    return; // Early return since we handle oscillator differently

                case 'move':
                    // Very subtle tick (optional, can be annoying)
                    break;
            }
        }

        // Settings UI
        document.querySelectorAll('[data-speed]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-speed]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSpeed = btn.dataset.speed;
            });
        });

        document.querySelectorAll('[data-size]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-size]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSize = btn.dataset.size;
            });
        });

        document.getElementById('obstaclesToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            obstaclesEnabled = this.classList.contains('active');
        });

        document.getElementById('soundToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            soundEnabled = this.classList.contains('active');
            if (soundEnabled) initAudio();
        });

        document.querySelectorAll('[data-skin]').forEach(btn => {
            btn.addEventListener('click', () => {
                const wasDifferent = currentSkin !== btn.dataset.skin;
                document.querySelectorAll('[data-skin]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSkin = btn.dataset.skin;
                // Apply skin immediately without restart
                draw();
                // Achievement for changing skin
                if (wasDifferent) checkAchievement('skin_change');
            });
        });

        // Theme selector
        let currentTheme = localStorage.getItem('snakeTheme') || 'neon';
        document.documentElement.setAttribute('data-theme', currentTheme);
        document.querySelector(`[data-theme="${currentTheme}"]`)?.classList.add('active');

        document.querySelectorAll('.theme-btn[data-theme]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.theme-btn[data-theme]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTheme = btn.dataset.theme;
                document.documentElement.setAttribute('data-theme', currentTheme);
                localStorage.setItem('snakeTheme', currentTheme);
                // Redraw to update canvas colors
                draw();
            });
        });

        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;
            });
        });

        document.getElementById('applySettings').addEventListener('click', () => {
            applySettings();
            init();
        });

        function applySettings() {
            baseSpeed = speedSettings[currentSpeed];
            gameSpeed = baseSpeed;

            const size = sizeSettings[currentSize];
            tileCount = size.tiles;
            canvas.width = size.pixels;
            canvas.height = size.pixels;
            gridSize = size.pixels / size.tiles;

            generateObstacles();
        }

        function generateObstacles() {
            obstacles = [];
            if (!obstaclesEnabled) return;

            const obstacleCount = Math.floor(tileCount * 0.8);
            const centerZone = Math.floor(tileCount / 3);

            for (let i = 0; i < obstacleCount; i++) {
                let obs;
                let attempts = 0;
                do {
                    obs = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCount)
                    };
                    attempts++;
                } while (
                    attempts < 50 &&
                    (
                        (obs.x >= centerZone && obs.x < tileCount - centerZone &&
                         obs.y >= centerZone && obs.y < tileCount - centerZone) ||
                        obstacles.some(o => o.x === obs.x && o.y === obs.y)
                    )
                );

                if (attempts < 50) {
                    obstacles.push(obs);
                }
            }
        }

        // Power-up functions
        function spawnPowerup() {
            const types = Object.keys(POWERUP_TYPES);
            const type = types[Math.floor(Math.random() * types.length)];

            let attempts = 0;
            let pos;
            do {
                pos = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                attempts++;
            } while (
                attempts < 100 &&
                (snake.some(seg => seg.x === pos.x && seg.y === pos.y) ||
                 obstacles.some(obs => obs.x === pos.x && obs.y === pos.y) ||
                 (food.x === pos.x && food.y === pos.y))
            );

            powerup = { ...pos, type };
        }

        function collectPowerup(type) {
            const powerupInfo = POWERUP_TYPES[type];
            activePowerups[type].active = true;
            activePowerups[type].endTime = Date.now() + powerupInfo.duration;

            // Apply immediate effects
            if (type === 'speed') {
                gameSpeed = Math.max(gameSpeed * 0.6, 30);
                clearInterval(gameLoop);
                gameLoop = setInterval(update, gameSpeed);
            } else if (type === 'slow') {
                gameSpeed = baseSpeed * 1.5;
                clearInterval(gameLoop);
                gameLoop = setInterval(update, gameSpeed);
            } else if (type === 'double') {
                scoreMultiplier = 2;
            }

            powerup = null;
            updatePowerupDisplay();
        }

        function updatePowerups() {
            const now = Date.now();

            for (const type of Object.keys(activePowerups)) {
                if (activePowerups[type].active && now >= activePowerups[type].endTime) {
                    activePowerups[type].active = false;

                    // Remove effects
                    if (type === 'speed' || type === 'slow') {
                        gameSpeed = baseSpeed;
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                    } else if (type === 'double') {
                        scoreMultiplier = 1;
                    }

                    updatePowerupDisplay();
                }
            }

            // Spawn new powerup (disabled in multiplayer)
            if (!isMultiplayer && !powerup && now - lastPowerupSpawn >= POWERUP_SPAWN_INTERVAL) {
                spawnPowerup();
                lastPowerupSpawn = now;
            }
        }

        function updatePowerupDisplay() {
            const now = Date.now();
            let html = '';

            for (const [type, state] of Object.entries(activePowerups)) {
                if (state.active) {
                    const remaining = Math.ceil((state.endTime - now) / 1000);
                    const info = POWERUP_TYPES[type];
                    html += `<div class="powerup-indicator ${type}">${info.name} ${remaining}s</div>`;
                }
            }

            activePowerupsEl.innerHTML = html;
        }

        // Username functions
        window.openUsernameModal = function() {
            usernameInput.value = customUsername || '';
            usernameModal.classList.add('show');
            usernameInput.focus();
        };

        window.closeUsernameModal = function() {
            usernameModal.classList.remove('show');
        };

        window.saveUsername = async function() {
            const newUsername = usernameInput.value.trim();
            if (newUsername && newUsername.length >= 2 && newUsername.length <= 20) {
                customUsername = newUsername;

                // Update display name in UI
                const userNameEl = document.querySelector('.user-name');
                if (userNameEl) {
                    userNameEl.textContent = customUsername;
                }

                // Save to Firebase if user is logged in
                if (currentUser) {
                    try {
                        const userRef = doc(db, 'users', currentUser.uid);
                        await setDoc(userRef, { customUsername: customUsername }, { merge: true });

                        // Also update the scores collection if user has a score
                        const scoreRef = doc(db, 'scores', currentUser.uid);
                        const scoreDoc = await getDoc(scoreRef);
                        if (scoreDoc.exists()) {
                            await setDoc(scoreRef, { displayName: customUsername }, { merge: true });
                            loadLeaderboard();
                        }
                    } catch (error) {
                        console.error("Error saving username:", error);
                    }
                }

                closeUsernameModal();
            }
        };

        // Load custom username on auth state change
        async function loadCustomUsername() {
            if (!currentUser) return;
            try {
                const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
                if (userDoc.exists() && userDoc.data().customUsername) {
                    customUsername = userDoc.data().customUsername;
                }
            } catch (error) {
                console.error("Error loading custom username:", error);
            }
        }

        // Username modal event listeners
        usernameSaveBtn.addEventListener('click', saveUsername);
        usernameCancelBtn.addEventListener('click', closeUsernameModal);
        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveUsername();
        });
        usernameModal.addEventListener('click', (e) => {
            if (e.target === usernameModal) closeUsernameModal();
        });

        // Fullscreen function
        window.toggleFullscreen = function() {
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const icon = document.getElementById('fullscreenIcon');

            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (gameContainer.requestFullscreen) {
                    gameContainer.requestFullscreen();
                } else if (gameContainer.webkitRequestFullscreen) {
                    gameContainer.webkitRequestFullscreen();
                }
                fullscreenBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
                        <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                    </svg>
                    Exit Fullscreen
                `;
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                fullscreenBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
                        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                    </svg>
                    Fullscreen
                `;
            }
        };

        // Listen for fullscreen change to update button
        document.addEventListener('fullscreenchange', () => {
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            if (!document.fullscreenElement) {
                fullscreenBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
                        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                    </svg>
                    Fullscreen
                `;
            }
        });

        // Auth functions
        window.signIn = async function() {
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Sign in error:", error);
            }
        };

        window.signOutUser = async function() {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Sign out error:", error);
            }
        };

        onAuthStateChanged(auth, async (user) => {
            currentUser = user;
            if (user) {
                // Load custom username first
                await loadCustomUsername();
                const displayName = customUsername || user.displayName || 'Player';

                // Check for multiplayer room in URL
                setTimeout(checkUrlForRoom, 500);

                authContainer.innerHTML = `
                    <div class="user-info">
                        <img class="user-avatar" src="${user.photoURL || 'https://via.placeholder.com/40'}" alt="avatar">
                        <span class="user-name">${displayName}</span>
                        <button class="edit-username-btn" onclick="openUsernameModal()" title="Edit username">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                        </button>
                        <button class="auth-btn sign-out" onclick="signOutUser()">Sign Out</button>
                    </div>
                `;
                await loadPersonalBest();
            } else {
                customUsername = null;
                authContainer.innerHTML = `
                    <button class="auth-btn" onclick="signIn()">
                        <svg class="google-icon" viewBox="0 0 24 24" style="width:18px;height:18px">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        Sign in with Google
                    </button>
                `;
                personalBest = parseInt(localStorage.getItem('snakeHighScore') || '0');
                highScoreEl.textContent = personalBest;
            }
            loadLeaderboard();
        });

        async function loadPersonalBest() {
            if (!currentUser) return;
            try {
                const userDoc = await getDoc(doc(db, 'scores', currentUser.uid));
                if (userDoc.exists()) {
                    personalBest = userDoc.data().score;
                    highScoreEl.textContent = personalBest;
                }
            } catch (error) {
                console.error("Error loading personal best:", error);
            }
        }

        async function saveScore(newScore) {
            if (!currentUser) {
                const localBest = parseInt(localStorage.getItem('snakeHighScore') || '0');
                if (newScore > localBest) {
                    localStorage.setItem('snakeHighScore', newScore);
                    personalBest = newScore;
                    highScoreEl.textContent = personalBest;
                    return true;
                }
                return false;
            }

            try {
                const userRef = doc(db, 'scores', currentUser.uid);
                const userDoc = await getDoc(userRef);
                const currentBest = userDoc.exists() ? userDoc.data().score : 0;

                if (newScore > currentBest) {
                    await setDoc(userRef, {
                        score: newScore,
                        displayName: customUsername || currentUser.displayName || 'Anonymous',
                        photoURL: currentUser.photoURL || '',
                        updatedAt: new Date(),
                        gameSettings: {
                            mode: currentMode,
                            speed: currentSpeed,
                            size: currentSize,
                            obstacles: obstaclesEnabled
                        }
                    });
                    personalBest = newScore;
                    highScoreEl.textContent = personalBest;
                    loadLeaderboard();
                    return true;
                }
            } catch (error) {
                console.error("Error saving score:", error);
            }
            return false;
        }

        async function loadLeaderboard() {
            const mobileLeaderboardList = document.getElementById('mobileLeaderboardList');

            try {
                const q = query(collection(db, 'scores'), orderBy('score', 'desc'), limit(10));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    leaderboardList.innerHTML = '<li class="no-scores">No scores yet. Be the first!</li>';
                    if (mobileLeaderboardList) {
                        mobileLeaderboardList.innerHTML = '<li style="color: var(--text-secondary); font-size: 0.85rem; padding: 8px; text-align: center;">No scores yet!</li>';
                    }
                    return;
                }

                leaderboardList.innerHTML = '';
                let mobileHtml = '';
                let rank = 1;
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const isCurrentUser = currentUser && doc.id === currentUser.uid;
                    const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : 'normal';
                    const rankEmoji = rank === 1 ? '' : rank === 2 ? '' : rank === 3 ? '' : `#${rank}`;

                    // Build settings badges HTML
                    let settingsHtml = '';
                    if (data.gameSettings) {
                        const gs = data.gameSettings;
                        settingsHtml = `
                            <div class="player-settings">
                                <span class="setting-badge mode">${gs.mode || 'classic'}</span>
                                <span class="setting-badge speed">${gs.speed || 'normal'}</span>
                                <span class="setting-badge size">${gs.size || 'medium'}</span>
                                ${gs.obstacles ? '<span class="setting-badge obstacles">obstacles</span>' : ''}
                            </div>
                        `;
                    }

                    leaderboardList.innerHTML += `
                        <li class="leaderboard-item ${isCurrentUser ? 'current-user' : ''}">
                            <span class="rank ${rankClass}">#${rank}</span>
                            <img class="player-avatar" src="${data.photoURL || 'https://via.placeholder.com/32'}" alt="">
                            <div class="player-info">
                                <div class="player-name">${data.displayName || 'Anonymous'}</div>
                                ${settingsHtml}
                            </div>
                            <span class="player-score">${data.score}</span>
                        </li>
                    `;

                    // Mobile leaderboard (simpler)
                    mobileHtml += `
                        <li style="display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; background: ${isCurrentUser ? 'rgba(0, 255, 136, 0.15)' : 'rgba(255,255,255,0.05)'}; border-radius: 8px; margin-bottom: 6px; ${isCurrentUser ? 'border: 1px solid var(--primary);' : ''}">
                            <span style="font-size: 0.9rem; min-width: 30px;">${rankEmoji}</span>
                            <span style="flex: 1; color: ${isCurrentUser ? 'var(--primary)' : 'var(--text-primary)'}; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin: 0 8px;">${data.displayName || 'Anonymous'}</span>
                            <span style="color: var(--gold); font-family: 'Orbitron', sans-serif; font-size: 0.85rem; font-weight: 600;">${data.score}</span>
                        </li>
                    `;
                    rank++;
                });

                // Update mobile leaderboard
                if (mobileLeaderboardList) {
                    mobileLeaderboardList.innerHTML = mobileHtml;
                }
            } catch (error) {
                console.error("Error loading leaderboard:", error);
                leaderboardList.innerHTML = '<li class="no-scores">Error loading leaderboard</li>';
                if (mobileLeaderboardList) {
                    mobileLeaderboardList.innerHTML = '<li style="color: var(--text-secondary); font-size: 0.85rem; padding: 8px; text-align: center;">Error loading</li>';
                }
            }
        }

        // Game functions
        function init() {
            const startX = Math.floor(tileCount / 4);
            const startY = Math.floor(tileCount / 2);

            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            gameSpeed = baseSpeed;
            scoreMultiplier = 1;
            powerup = null;
            lastPowerupSpawn = Date.now();
            gameStartTime = Date.now();
            totalFoodEaten = 0;
            combo = 0;
            lastFoodTime = 0;
            document.getElementById('comboDisplay').innerHTML = '';

            // Mode achievements
            if (currentMode === 'nowalls') checkAchievement('no_walls');
            if (currentMode === 'timeattack') checkAchievement('time_attack');
            if (currentMode === 'zen') checkAchievement('zen_master');

            // Reset powerups
            for (const type of Object.keys(activePowerups)) {
                activePowerups[type] = { active: false, endTime: 0 };
            }
            activePowerupsEl.innerHTML = '';

            // Setup game mode
            const mode = GAME_MODES[currentMode];
            const modeIndicator = document.getElementById('modeIndicator');
            const timerDisplay = document.getElementById('timerDisplay');
            const timerEl = document.getElementById('timer');

            modeIndicator.innerHTML = `Mode: <span>${mode.name}</span> - ${mode.description}`;

            // Clear any existing timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // Setup timer for Time Attack
            if (mode.hasTimer) {
                timeLeft = mode.timerDuration;
                timerEl.textContent = timeLeft;
                timerDisplay.style.display = 'block';
                timerDisplay.classList.remove('urgent');

                timerInterval = setInterval(() => {
                    if (!isPaused) {
                        timeLeft--;
                        timerEl.textContent = timeLeft;

                        if (timeLeft <= 10) {
                            timerDisplay.classList.add('urgent');
                        }

                        if (timeLeft <= 0) {
                            clearInterval(timerInterval);
                            timerInterval = null;
                            gameOver();
                        }
                    }
                }, 1000);
            } else {
                timerDisplay.style.display = 'none';
            }

            scoreEl.textContent = score;
            spawnFood();
            gameOverEl.style.display = 'none';
            newRecordEl.style.display = 'none';
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);

            // Auto-center view on mobile when game starts
            if (window.innerWidth <= 600) {
                setTimeout(() => {
                    const canvas = document.getElementById('gameCanvas');
                    if (canvas) {
                        canvas.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center',
                            inline: 'center'
                        });
                    }
                }, 100);
            }
        }

        function spawnFood() {
            let attempts = 0;
            do {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                attempts++;
            } while (
                attempts < 100 &&
                (snake.some(seg => seg.x === food.x && seg.y === food.y) ||
                 obstacles.some(obs => obs.x === food.x && obs.y === food.y))
            );

            // Pick random food type based on chance
            const roll = Math.random() * 100;
            let cumulative = 0;
            for (const [type, info] of Object.entries(FOOD_TYPES)) {
                cumulative += info.chance;
                if (roll < cumulative) {
                    food.type = type;
                    break;
                }
            }
            if (!food.type) food.type = 'apple';
        }

        function update() {
            if (isPaused) return;

            // Spectators only watch - don't update their own snake
            if (isSpectating) {
                draw(); // Still draw to see other players
                return;
            }

            // Safety check - if snake is empty, don't try to update
            if (!snake || snake.length === 0) {
                draw();
                return;
            }

            updatePowerups();
            updatePowerupDisplay();

            direction = { ...nextDirection };

            const head = {
                x: snake[0].x + direction.x,
                y: snake[0].y + direction.y
            };

            const mode = GAME_MODES[currentMode];
            const canPassWalls = activePowerups.shield.active || mode.noWalls;
            const canDie = !mode.noDeath && !activePowerups.shield.active;

            // Wall collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                if (canPassWalls) {
                    // Wrap around
                    if (head.x < 0) head.x = tileCount - 1;
                    if (head.x >= tileCount) head.x = 0;
                    if (head.y < 0) head.y = tileCount - 1;
                    if (head.y >= tileCount) head.y = 0;
                } else if (canDie) {
                    gameOver();
                    return;
                }
            }

            // Self collision
            if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
                if (canDie) {
                    gameOver();
                    return;
                } else {
                    // In zen mode, teleport head away from collision
                    head.x = (head.x + Math.floor(tileCount / 2)) % tileCount;
                    head.y = (head.y + Math.floor(tileCount / 2)) % tileCount;
                }
            }

            // Obstacle collision
            if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) {
                if (canDie) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head);

            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                // Safety check for food type
                const foodType = food.type || 'apple';
                const foodInfo = FOOD_TYPES[foodType] || FOOD_TYPES['apple'];
                totalFoodEaten++;

                // Achievements for food
                checkAchievement('first_food');
                if (food.type === 'golden') {
                    checkAchievement('golden_catch');
                    goldenEatenToday++;
                    updateDailyChallengeProgress('golden', goldenEatenToday);
                }

                // Daily challenge - food count
                updateDailyChallengeProgress('food', totalFoodEaten);

                // Play appropriate sound
                if (food.type === 'rotten') {
                    playSound('death'); // Bad sound for rotten
                } else if (food.type === 'golden') {
                    playSound('powerup'); // Special sound for golden
                } else {
                    playSound('eat');
                }

                // Add points with combo multiplier (rotten food doesn't benefit from combo)
                const comboMultiplier = food.type !== 'rotten' ? addCombo() : 1;
                if (food.type === 'rotten') combo = 0; // Rotten food breaks combo
                const points = Math.floor(foodInfo.points * scoreMultiplier * comboMultiplier);
                score = Math.max(0, score + points);
                scoreEl.textContent = score;

                // Score achievements
                if (score >= 50) checkAchievement('score_50');
                if (score >= 100) checkAchievement('score_100');
                if (score >= 250) checkAchievement('score_250');
                if (score >= 500) checkAchievement('score_500');
                if (score >= 1000) checkAchievement('score_1000');

                // Daily challenge - score
                updateDailyChallengeProgress('score', score);

                // Handle growth (positive = grow, negative = shrink)
                if (foodInfo.grow > 0) {
                    // Add extra segments for growth > 1
                    for (let i = 1; i < foodInfo.grow; i++) {
                        snake.push({ ...snake[snake.length - 1] });
                    }
                } else if (foodInfo.grow < 0) {
                    // Shrink snake (but keep minimum length of 2)
                    for (let i = 0; i < Math.abs(foodInfo.grow) && snake.length > 2; i++) {
                        snake.pop();
                    }
                    snake.pop(); // Normal pop
                }

                // Spawn new food (multiplayer: host controls food)
                if (isMultiplayer && currentGameId) {
                    handleMultiplayerFoodCollision();
                } else {
                    spawnFood();
                }

                // Length achievements
                if (snake.length >= 10) checkAchievement('length_10');
                if (snake.length >= 20) checkAchievement('length_20');
                if (snake.length >= 50) checkAchievement('length_50');

                // Daily challenge - length and combo
                updateDailyChallengeProgress('length', snake.length);
                updateDailyChallengeProgress('combo', combo);

                const minSpeed = Math.max(baseSpeed * 0.5, 30);
                if (gameSpeed > minSpeed && !activePowerups.slow.active && foodInfo.grow > 0) {
                    gameSpeed -= 2;
                    clearInterval(gameLoop);
                    gameLoop = setInterval(update, gameSpeed);
                }
            } else {
                snake.pop();
            }

            // Check powerup collision
            if (powerup && head.x === powerup.x && head.y === powerup.y) {
                playSound('powerup');
                collectPowerup(powerup.type);
                checkAchievement('powerup_collect');
            }

            // Check survive achievement (60 seconds)
            const surviveTime = (Date.now() - gameStartTime) / 1000;
            if (surviveTime >= 60) checkAchievement('survive_60');

            // Update combo display
            updateComboDisplay();

            draw();
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Obstacles
            obstacles.forEach(obs => {
                ctx.fillStyle = '#ff6600';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.roundRect(
                    obs.x * gridSize + 2,
                    obs.y * gridSize + 2,
                    gridSize - 4,
                    gridSize - 4,
                    4
                );
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Power-up
            if (powerup) {
                const pColor = POWERUP_TYPES[powerup.type].color;
                ctx.fillStyle = pColor;
                ctx.shadowColor = pColor;
                ctx.shadowBlur = 20;

                // Draw star shape
                const cx = powerup.x * gridSize + gridSize / 2;
                const cy = powerup.y * gridSize + gridSize / 2;
                const spikes = 5;
                const outerRadius = gridSize / 2 - 2;
                const innerRadius = gridSize / 4;

                ctx.beginPath();
                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI / spikes) - Math.PI / 2;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Food
            const foodInfo = FOOD_TYPES[food.type] || FOOD_TYPES.apple;
            ctx.fillStyle = foodInfo.color;
            ctx.shadowColor = foodInfo.color;
            ctx.shadowBlur = food.type === 'golden' ? 25 : 15;

            const fx = food.x * gridSize + gridSize / 2;
            const fy = food.y * gridSize + gridSize / 2;

            if (food.type === 'golden') {
                // Golden apple - sparkly diamond shape
                ctx.beginPath();
                ctx.moveTo(fx, fy - gridSize / 2 + 2);
                ctx.lineTo(fx + gridSize / 2 - 2, fy);
                ctx.lineTo(fx, fy + gridSize / 2 - 2);
                ctx.lineTo(fx - gridSize / 2 + 2, fy);
                ctx.closePath();
                ctx.fill();
            } else if (food.type === 'cherry') {
                // Cherry - two small circles
                const cherryR = gridSize / 4;
                ctx.beginPath();
                ctx.arc(fx - cherryR / 2, fy + 2, cherryR, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(fx + cherryR / 2 + 2, fy - 2, cherryR, 0, Math.PI * 2);
                ctx.fill();
                // Stem
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(fx - cherryR / 2, fy - cherryR + 2);
                ctx.quadraticCurveTo(fx, fy - gridSize / 2, fx + cherryR / 2 + 2, fy - cherryR);
                ctx.stroke();
            } else if (food.type === 'rotten') {
                // Rotten - irregular blob with X
                ctx.beginPath();
                ctx.arc(fx, fy, gridSize / 2 - 3, 0, Math.PI * 2);
                ctx.fill();
                // Draw X mark
                ctx.strokeStyle = '#2d1810';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(fx - 4, fy - 4);
                ctx.lineTo(fx + 4, fy + 4);
                ctx.moveTo(fx + 4, fy - 4);
                ctx.lineTo(fx - 4, fy + 4);
                ctx.stroke();
            } else {
                // Regular apple - circle
                ctx.beginPath();
                ctx.arc(fx, fy, gridSize / 2 - 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;

            // Snake
            const skin = SNAKE_SKINS[currentSkin];
            snake.forEach((segment, index) => {
                const alpha = 1 - (index / snake.length) * 0.5;

                // Handle shield override or skin colors
                if (activePowerups.shield.active) {
                    ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.shadowColor = '#00ffff';
                } else if (skin.primary === 'rainbow') {
                    // Rainbow effect - each segment is different color
                    const hue = ((index * 30) + Date.now() / 20) % 360;
                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                } else {
                    // Gradient between primary and secondary based on position
                    const colorRatio = index / Math.max(snake.length - 1, 1);
                    ctx.fillStyle = index === 0
                        ? hexToRgba(skin.primary, alpha)
                        : hexToRgba(lerpColor(skin.primary, skin.secondary, colorRatio), alpha);
                    ctx.shadowColor = skin.glow;
                }
                ctx.shadowBlur = index === 0 ? 10 : 5;

                ctx.beginPath();
                ctx.roundRect(
                    segment.x * gridSize + 1,
                    segment.y * gridSize + 1,
                    gridSize - 2,
                    gridSize - 2,
                    5
                );
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Eyes
            if (snake.length > 0) {
                const head = snake[0];
                ctx.fillStyle = activePowerups.shield.active ? '#1a1a2e' : skin.eye;

                let eye1X, eye1Y, eye2X, eye2Y;
                const eyeOffset = gridSize * 0.3;
                const eyeSize = gridSize * 0.15;

                if (direction.x === 1) {
                    eye1X = head.x * gridSize + gridSize - eyeOffset;
                    eye1Y = head.y * gridSize + eyeOffset;
                    eye2X = head.x * gridSize + gridSize - eyeOffset;
                    eye2Y = head.y * gridSize + gridSize - eyeOffset;
                } else if (direction.x === -1) {
                    eye1X = head.x * gridSize + eyeOffset;
                    eye1Y = head.y * gridSize + eyeOffset;
                    eye2X = head.x * gridSize + eyeOffset;
                    eye2Y = head.y * gridSize + gridSize - eyeOffset;
                } else if (direction.y === -1) {
                    eye1X = head.x * gridSize + eyeOffset;
                    eye1Y = head.y * gridSize + eyeOffset;
                    eye2X = head.x * gridSize + gridSize - eyeOffset;
                    eye2Y = head.y * gridSize + eyeOffset;
                } else {
                    eye1X = head.x * gridSize + eyeOffset;
                    eye1Y = head.y * gridSize + gridSize - eyeOffset;
                    eye2X = head.x * gridSize + gridSize - eyeOffset;
                    eye2Y = head.y * gridSize + gridSize - eyeOffset;
                }

                ctx.beginPath();
                ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw ghost players (multiplayer)
            if (isMultiplayer && Object.keys(otherPlayers).length > 0) {
                drawGhostPlayers();
            }

            // Pause overlay
            if (isPaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ff88';
                ctx.font = `bold ${gridSize * 1.5}px Segoe UI`;
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        function screenShake() {
            const wrapper = document.querySelector('.canvas-wrapper');
            wrapper.classList.add('shake');
            canvas.classList.add('flash');

            setTimeout(() => {
                wrapper.classList.remove('shake');
                canvas.classList.remove('flash');
            }, 500);
        }

        async function gameOver() {
            // Handle multiplayer death differently
            if (isMultiplayer && currentGameId) {
                playSound('death');
                screenShake();
                await handleMultiplayerDeath();
                return;
            }

            clearInterval(gameLoop);
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            playSound('death');
            screenShake();

            // Small delay before showing game over for dramatic effect
            await new Promise(resolve => setTimeout(resolve, 300));

            finalScoreEl.textContent = score;
            const isNewRecord = await saveScore(score);

            if (isNewRecord && score > 0) {
                newRecordEl.style.display = 'block';
                playSound('highscore');
            } else {
                newRecordEl.style.display = 'none';
            }

            gameOverEl.style.display = 'flex';
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            initAudio(); // Initialize audio on first interaction

            // Prevent arrow keys and space from scrolling the page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
                    break;
                case ' ':
                    isPaused = !isPaused;
                    draw();
                    break;
                case 'f':
                case 'F':
                    toggleFullscreen();
                    break;
                case 'Escape':
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                    break;
            }
        });

        // Mobile controls with touch support
        const upBtn = document.getElementById('upBtn');
        const downBtn = document.getElementById('downBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');

        function handleUp(e) {
            e.preventDefault();
            initAudio();
            if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
        }
        function handleDown(e) {
            e.preventDefault();
            initAudio();
            if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
        }
        function handleLeft(e) {
            e.preventDefault();
            initAudio();
            if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
        }
        function handleRight(e) {
            e.preventDefault();
            initAudio();
            if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
        }

        // Use both touchstart (for mobile) and click (for desktop testing)
        upBtn.addEventListener('touchstart', handleUp, { passive: false });
        upBtn.addEventListener('click', handleUp);
        downBtn.addEventListener('touchstart', handleDown, { passive: false });
        downBtn.addEventListener('click', handleDown);
        leftBtn.addEventListener('touchstart', handleLeft, { passive: false });
        leftBtn.addEventListener('click', handleLeft);
        rightBtn.addEventListener('touchstart', handleRight, { passive: false });
        rightBtn.addEventListener('click', handleRight);

        // Mobile Pause Button
        const mobilePauseBtn = document.getElementById('mobilePauseBtn');
        if (mobilePauseBtn) {
            function handlePause(e) {
                e.preventDefault();
                isPaused = !isPaused;
                mobilePauseBtn.textContent = isPaused ? '' : '';
                draw();
            }
            mobilePauseBtn.addEventListener('touchstart', handlePause, { passive: false });
            mobilePauseBtn.addEventListener('click', handlePause);
        }

        restartBtn.addEventListener('click', () => {
            window.scrollTo(0, 0);
            init();
        });

        // Fix mobile viewport height issues (browser chrome appearing/disappearing)
        function fixMobileViewport() {
            // Set CSS variable for actual viewport height
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            // Scroll to top to fix layout
            window.scrollTo(0, 0);
        }

        // Run on load
        fixMobileViewport();

        // Run on resize and orientation change
        window.addEventListener('resize', fixMobileViewport);
        window.addEventListener('orientationchange', () => {
            setTimeout(fixMobileViewport, 100);
        });

        // Use visualViewport API if available (better for mobile)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', fixMobileViewport);
        }

        // Hide loading screen after everything loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
            }, 2200);
        });

        // Fallback: hide loading screen after 4 seconds no matter what
        setTimeout(() => {
            const ls = document.getElementById('loadingScreen');
            if (ls && !ls.classList.contains('hidden')) {
                ls.classList.add('hidden');
            }
        }, 4000);

        // ===== GUIDE MODAL FUNCTIONS =====
        const guideModal = document.getElementById('guideModal');
        const guideCloseBtn = document.getElementById('guideCloseBtn');
        const helpBtn = document.getElementById('helpBtn');
        const guideTabs = document.querySelectorAll('.guide-tab');
        const guideSections = document.querySelectorAll('.guide-section');

        // Check if user has seen the guide before
        const hasSeenGuide = localStorage.getItem('snakeGuideShown');

        // Open guide modal
        function openGuide() {
            guideModal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        // Close guide modal
        function closeGuide() {
            guideModal.classList.remove('active');
            document.body.style.overflow = '';
            localStorage.setItem('snakeGuideShown', 'true');
        }

        // Switch guide tabs
        function switchGuideTab(tabName) {
            guideTabs.forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            guideSections.forEach(section => {
                section.classList.toggle('active', section.id === `guide-${tabName}`);
            });
        }

        // Event listeners for guide
        if (helpBtn) {
            helpBtn.addEventListener('click', openGuide);
        }

        if (guideCloseBtn) {
            guideCloseBtn.addEventListener('click', closeGuide);
        }

        // Close on backdrop click
        if (guideModal) {
            guideModal.addEventListener('click', (e) => {
                if (e.target === guideModal) {
                    closeGuide();
                }
            });
        }

        // Tab switching
        guideTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                switchGuideTab(tab.dataset.tab);
            });
        });

        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && guideModal.classList.contains('active')) {
                closeGuide();
            }
        });

        // Show guide for first-time visitors after loading screen hides
        if (!hasSeenGuide) {
            setTimeout(() => {
                openGuide();
            }, 2500);
        }

        // ===== MOBILE SETTINGS PANEL =====
        const mobileSettingsToggle = document.getElementById('mobileSettingsToggle');
        const mobileSettingsPanel = document.getElementById('mobileSettingsPanel');
        const mobileSettingsOverlay = document.getElementById('mobileSettingsOverlay');
        const mobilePlayBtn = document.getElementById('mobilePlayBtn');
        const mobileObstaclesToggle = document.getElementById('mobileObstaclesToggle');

        function openMobileSettings() {
            mobileSettingsPanel.classList.add('active');
            mobileSettingsOverlay.classList.add('active');
            mobileSettingsToggle.classList.add('active');
        }

        function closeMobileSettings() {
            mobileSettingsPanel.classList.remove('active');
            mobileSettingsOverlay.classList.remove('active');
            mobileSettingsToggle.classList.remove('active');
        }

        if (mobileSettingsToggle) {
            mobileSettingsToggle.addEventListener('click', () => {
                if (mobileSettingsPanel.classList.contains('active')) {
                    closeMobileSettings();
                } else {
                    openMobileSettings();
                }
            });
        }

        if (mobileSettingsOverlay) {
            mobileSettingsOverlay.addEventListener('click', closeMobileSettings);
        }

        // Mobile Play Button
        if (mobilePlayBtn) {
            mobilePlayBtn.addEventListener('click', () => {
                closeMobileSettings();
                initAudio();
                init();
            });
        }

        // Mobile Mode Buttons
        document.querySelectorAll('.mobile-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mobile-mode-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const mode = btn.dataset.mode;
                document.querySelector(`[data-mode="${mode}"]:not(.mobile-mode-btn)`)?.classList.add('active');
                currentMode = mode;
            });
        });

        // Mobile Speed Buttons
        document.querySelectorAll('.mobile-speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mobile-speed-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('[data-speed]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const speed = btn.dataset.speed;
                document.querySelector(`[data-speed="${speed}"]:not(.mobile-speed-btn)`)?.classList.add('active');
                currentSpeed = speed;
            });
        });

        // Mobile Size Buttons
        document.querySelectorAll('.mobile-size-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mobile-size-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('[data-size]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const size = btn.dataset.size;
                document.querySelector(`[data-size="${size}"]:not(.mobile-size-btn)`)?.classList.add('active');
                currentSize = size;
            });
        });

        // Mobile Theme Buttons
        document.querySelectorAll('.mobile-theme-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mobile-theme-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.theme-btn[data-theme]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const theme = btn.dataset.theme;
                document.querySelector(`.theme-btn[data-theme="${theme}"]`)?.classList.add('active');
                currentTheme = theme;
                document.body.setAttribute('data-theme', theme);
            });
        });

        // Mobile Obstacles Toggle
        if (mobileObstaclesToggle) {
            mobileObstaclesToggle.addEventListener('change', () => {
                obstaclesEnabled = mobileObstaclesToggle.checked;
                // Sync with desktop toggle (which uses class, not checkbox)
                const mainToggle = document.getElementById('obstaclesToggle');
                if (mainToggle) {
                    if (obstaclesEnabled) {
                        mainToggle.classList.add('active');
                    } else {
                        mainToggle.classList.remove('active');
                    }
                }
            });
        }

        // Mobile Players Selection
        const mobileMpControls = document.getElementById('mobileMpControls');
        const mobileCreateRoomBtn = document.getElementById('mobileCreateRoomBtn');
        const mobileJoinRoomBtn = document.getElementById('mobileJoinRoomBtn');
        const mobileRoomCodeInput = document.getElementById('mobileRoomCodeInput');

        document.querySelectorAll('.mobile-players-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mobile-players-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('[data-players]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const players = parseInt(btn.dataset.players);
                document.querySelector(`[data-players="${players}"]:not(.mobile-players-btn)`)?.classList.add('active');
                playerCount = players;
                isMultiplayer = players > 1;

                // Show/hide multiplayer controls
                if (mobileMpControls) {
                    mobileMpControls.style.display = isMultiplayer ? 'block' : 'none';
                }

                // Also update main multiplayer controls visibility
                const multiplayerControls = document.getElementById('multiplayerControls');
                if (multiplayerControls) {
                    multiplayerControls.style.display = isMultiplayer ? 'block' : 'none';
                }
            });
        });

        // Mobile Create Room Button
        if (mobileCreateRoomBtn) {
            mobileCreateRoomBtn.addEventListener('click', async () => {
                if (!currentUser) {
                    alert('Please sign in to create a multiplayer room');
                    return;
                }
                closeMobileSettings();
                await createMultiplayerRoom(playerCount);
            });
        }

        // Mobile Join Room Button
        if (mobileJoinRoomBtn) {
            mobileJoinRoomBtn.addEventListener('click', async () => {
                const roomCode = mobileRoomCodeInput ? mobileRoomCodeInput.value.trim().toUpperCase() : '';
                if (!roomCode) {
                    alert('Please enter a room code');
                    return;
                }
                if (!currentUser) {
                    alert('Please sign in to join a multiplayer room');
                    return;
                }
                closeMobileSettings();
                await joinMultiplayerRoom(roomCode);
            });
        }

        // ===== MULTIPLAYER FUNCTIONS =====

        // DOM elements for multiplayer (with null checks)
        const mpLobbyModal = document.getElementById('mpLobbyModal');
        const mpLobbyClose = document.getElementById('mpLobbyClose');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const copyRoomCode = document.getElementById('copyRoomCode');
        const copyRoomLink = document.getElementById('copyRoomLink');
        const lobbyMode = document.getElementById('lobbyMode');
        const lobbySpeed = document.getElementById('lobbySpeed');
        const lobbySize = document.getElementById('lobbySize');
        const playerCountDisplay = document.getElementById('playerCountDisplay');
        const maxPlayersDisplay = document.getElementById('maxPlayersDisplay');
        const mpPlayersList = document.getElementById('mpPlayersList');
        const mpReadyBtn = document.getElementById('mpReadyBtn');
        const mpStartBtn = document.getElementById('mpStartBtn');
        const mpLeaveBtn = document.getElementById('mpLeaveBtn');
        const mpLobbyStatus = document.getElementById('mpLobbyStatus');
        const mpHud = document.getElementById('mpHud');
        const mpLivesDisplay = document.getElementById('mpLivesDisplay');
        const mpScoresDisplay = document.getElementById('mpScoresDisplay');
        const mpResultsModal = document.getElementById('mpResultsModal');
        const mpResultsWinner = document.getElementById('mpResultsWinner');
        const mpResultsRankings = document.getElementById('mpResultsRankings');
        const mpPlayAgain = document.getElementById('mpPlayAgain');
        const mpExitResults = document.getElementById('mpExitResults');
        const multiplayerControls = document.getElementById('multiplayerControls');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const joinRoomBtn = document.getElementById('joinRoomBtn');

        // Player count selection (with null check)
        document.querySelectorAll('[data-players]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-players]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                playerCount = parseInt(btn.dataset.players);
                isMultiplayer = playerCount > 1;
                if (multiplayerControls) multiplayerControls.style.display = isMultiplayer ? 'block' : 'none';
            });
        });

        // Create room button
        if (createRoomBtn) {
            createRoomBtn.addEventListener('click', async () => {
                if (!currentUser) {
                    alert('Please sign in to create a multiplayer room');
                    return;
                }
                await createMultiplayerRoom(playerCount);
            });
        }

        // Join room button
        if (joinRoomBtn) {
            joinRoomBtn.addEventListener('click', async () => {
                const roomCode = roomCodeInput ? roomCodeInput.value.trim().toUpperCase() : '';
                if (!roomCode) {
                    alert('Please enter a room code');
                    return;
                }
                if (!currentUser) {
                    alert('Please sign in to join a multiplayer room');
                    return;
                }
                await joinMultiplayerRoom(roomCode);
            });
        }

        // Create multiplayer room
        async function createMultiplayerRoom(maxPlayers) {
            if (!rtdb) {
                alert('Multiplayer is not available. Please refresh and try again.');
                console.error('rtdb is null - Firebase Realtime Database not initialized');
                return;
            }

            try {
                console.log('Creating multiplayer room...');
                const gameRef = push(ref(rtdb, 'games'));
                // Generate a cleaner room code (skip the leading '-' in push keys)
                const gameId = gameRef.key.substring(1, 7).toUpperCase(); // Short room code
                console.log('Generated room code:', gameId);

                const displayName = customUsername || currentUser.displayName || 'Player';
                const colorIndex = 0;
                myPlayerColor = PLAYER_COLORS[colorIndex];

                const gameData = {
                    hostId: currentUser.uid,
                    status: 'waiting',
                    mode: currentMode,
                    speed: currentSpeed,
                    mapSize: currentSize,
                    obstacles: obstaclesEnabled,
                    maxPlayers: maxPlayers,
                    createdAt: Date.now(),
                    players: {
                        [currentUser.uid]: {
                            name: displayName,
                            color: myPlayerColor,
                            colorIndex: colorIndex,
                            lives: 3,
                            score: 0,
                            finalScore: 0,
                            snake: [],
                            direction: { x: 1, y: 0 },
                            alive: true,
                            ready: false,
                            isHost: true
                        }
                    }
                };

                // Store with short ID
                await set(ref(rtdb, `games/${gameId}`), gameData);

                currentGameId = gameId;
                isHost = true;
                isMultiplayer = true;

                // Set up disconnect cleanup
                const playerRef = ref(rtdb, `games/${gameId}/players/${currentUser.uid}`);
                onDisconnect(playerRef).remove();

                // Listen for game state changes
                listenToGameState(gameId);

                // Show lobby
                showLobby(gameId, gameData);

            } catch (error) {
                console.error('Error creating room:', error);
                alert('Failed to create room. Please try again.');
            }
        }

        // Join multiplayer room
        async function joinMultiplayerRoom(gameId) {
            if (!rtdb) {
                alert('Multiplayer is not available. Please refresh and try again.');
                console.error('rtdb is null - Firebase Realtime Database not initialized');
                return;
            }

            console.log('Attempting to join room:', gameId);

            try {
                const gameSnapshot = await get(ref(rtdb, `games/${gameId}`));
                console.log('Room lookup result:', gameSnapshot.exists() ? 'found' : 'not found');

                if (!gameSnapshot.exists()) {
                    alert('Room not found. Please check the code and try again.');
                    return;
                }

                const gameData = gameSnapshot.val();
                console.log('Room data:', gameData);

                if (gameData.status !== 'waiting') {
                    alert('This game has already started.');
                    return;
                }

                const currentPlayers = Object.keys(gameData.players || {}).length;
                if (currentPlayers >= gameData.maxPlayers) {
                    alert('This room is full.');
                    return;
                }

                // Check if already in room
                if (gameData.players && gameData.players[currentUser.uid]) {
                    // Already in room, just show lobby
                    currentGameId = gameId;
                    isHost = gameData.hostId === currentUser.uid;
                    isMultiplayer = true;
                    listenToGameState(gameId);
                    showLobby(gameId, gameData);
                    return;
                }

                // Assign color
                const usedColorIndices = Object.values(gameData.players || {}).map(p => p.colorIndex);
                let colorIndex = 0;
                for (let i = 0; i < PLAYER_COLORS.length; i++) {
                    if (!usedColorIndices.includes(i)) {
                        colorIndex = i;
                        break;
                    }
                }
                myPlayerColor = PLAYER_COLORS[colorIndex];

                const displayName = customUsername || currentUser.displayName || 'Player';
                console.log('Joining as:', displayName, 'with UID:', currentUser.uid);

                // Add player to room
                const playerData = {
                    name: displayName,
                    color: myPlayerColor,
                    colorIndex: colorIndex,
                    lives: 3,
                    score: 0,
                    finalScore: 0,
                    snake: [],
                    direction: { x: 1, y: 0 },
                    alive: true,
                    ready: false,
                    isHost: false
                };

                try {
                    await set(ref(rtdb, `games/${gameId}/players/${currentUser.uid}`), playerData);
                    console.log('Successfully added player to room');
                } catch (writeError) {
                    console.error('Failed to write player data:', writeError);
                    alert('Failed to join room. Firebase permissions may not be configured. Check console for details.');
                    return;
                }

                currentGameId = gameId;
                isHost = false;
                isMultiplayer = true;

                // Apply host's settings
                currentMode = gameData.mode;
                currentSpeed = gameData.speed;
                currentSize = gameData.mapSize;
                obstaclesEnabled = gameData.obstacles;

                // Update UI to reflect host's settings
                document.querySelectorAll('[data-mode]').forEach(b => {
                    b.classList.toggle('active', b.dataset.mode === currentMode);
                });
                document.querySelectorAll('[data-speed]').forEach(b => {
                    b.classList.toggle('active', b.dataset.speed === currentSpeed);
                });
                document.querySelectorAll('[data-size]').forEach(b => {
                    b.classList.toggle('active', b.dataset.size === currentSize);
                });

                // Set up disconnect cleanup
                const playerRef = ref(rtdb, `games/${gameId}/players/${currentUser.uid}`);
                onDisconnect(playerRef).remove();

                // Listen for game state changes
                listenToGameState(gameId);

                // Show lobby
                showLobby(gameId, gameData);

            } catch (error) {
                console.error('Error joining room:', error);
                alert('Failed to join room. Please try again.');
            }
        }

        // Show lobby modal
        function showLobby(gameId, gameData) {
            roomCodeDisplay.textContent = gameId;
            lobbyMode.textContent = GAME_MODES[gameData.mode]?.name || gameData.mode;
            lobbySpeed.textContent = gameData.speed.charAt(0).toUpperCase() + gameData.speed.slice(1);
            lobbySize.textContent = gameData.mapSize.charAt(0).toUpperCase() + gameData.mapSize.slice(1);
            maxPlayersDisplay.textContent = gameData.maxPlayers;

            // Show obstacles setting
            const lobbyObstacles = document.getElementById('lobbyObstacles');
            if (lobbyObstacles) {
                lobbyObstacles.textContent = gameData.obstacles ? 'Obstacles On' : 'No Obstacles';
            }

            mpStartBtn.style.display = isHost ? 'block' : 'none';
            mpReadyBtn.textContent = 'Ready';
            mpReadyBtn.classList.remove('ready');

            // Show/hide host settings panel
            const mpHostSettings = document.getElementById('mpHostSettings');
            const mpGameSettings = document.getElementById('mpGameSettings');
            if (mpHostSettings) {
                mpHostSettings.style.display = isHost ? 'block' : 'none';
            }
            if (mpGameSettings) {
                mpGameSettings.style.display = isHost ? 'none' : 'flex';
            }

            // Update host settings buttons to match current settings
            if (isHost) {
                document.querySelectorAll('[data-mp-mode]').forEach(b => {
                    b.classList.toggle('active', b.dataset.mpMode === gameData.mode);
                });
                document.querySelectorAll('[data-mp-speed]').forEach(b => {
                    b.classList.toggle('active', b.dataset.mpSpeed === gameData.speed);
                });
                document.querySelectorAll('[data-mp-size]').forEach(b => {
                    b.classList.toggle('active', b.dataset.mpSize === gameData.mapSize);
                });
                document.querySelectorAll('[data-mp-obstacles]').forEach(b => {
                    b.classList.toggle('active', (b.dataset.mpObstacles === 'true') === gameData.obstacles);
                });
            }

            mpLobbyModal.classList.add('show');
            updateLobbyPlayers(gameData.players);
        }

        // Update lobby players list
        function updateLobbyPlayers(players) {
            if (!players) return;

            const playerArray = Object.entries(players);
            playerCountDisplay.textContent = playerArray.length;

            mpPlayersList.innerHTML = playerArray.map(([playerId, player]) => `
                <div class="mp-player-item">
                    <div class="mp-player-color" style="background-color: ${player.color}; color: ${player.color};"></div>
                    <div class="mp-player-name">${player.name}</div>
                    ${player.isHost ? '<span class="mp-player-host">Host</span>' : ''}
                    <span class="mp-player-ready ${player.ready ? 'ready' : 'waiting'}">
                        ${player.ready ? 'Ready' : 'Waiting'}
                    </span>
                    ${isHost && !player.isHost ? `<button class="mp-kick-btn" onclick="kickPlayer('${playerId}')">Kick</button>` : ''}
                </div>
            `).join('');

            // Update status
            const allReady = playerArray.every(([_, p]) => p.ready);
            const enoughPlayers = playerArray.length >= 2;

            if (allReady && enoughPlayers) {
                mpLobbyStatus.textContent = isHost ? 'All players ready! Start the game.' : 'Waiting for host to start...';
                mpStartBtn.disabled = false;
            } else if (!enoughPlayers) {
                mpLobbyStatus.textContent = 'Waiting for more players...';
                mpStartBtn.disabled = true;
            } else {
                mpLobbyStatus.textContent = 'Waiting for players to ready up...';
                mpStartBtn.disabled = true;
            }
        }

        // Listen to game state changes
        function listenToGameState(gameId) {
            console.log('Setting up listener for room:', gameId);

            if (gameStateListener) {
                // Remove previous listener
                console.log('Removing previous listener');
                gameStateListener();
            }

            gameStateListener = onValue(ref(rtdb, `games/${gameId}`), (snapshot) => {
                console.log('Game state update received');

                if (!snapshot.exists()) {
                    // Room was deleted
                    console.log('Room no longer exists');
                    closeLobby();
                    alert('The room has been closed.');
                    return;
                }

                const gameData = snapshot.val();
                console.log('Game state:', gameData.status, 'Players:', Object.keys(gameData.players || {}).length);

                // Check if current player was kicked
                if (gameData.players && !gameData.players[currentUser.uid]) {
                    console.log('Player was kicked from the room');
                    cleanupMultiplayer();
                    mpLobbyModal.classList.remove('show');
                    if (mpResultsModal) mpResultsModal.classList.remove('show');
                    alert('You have been removed from the room.');
                    return;
                }

                if (gameData.status === 'waiting') {
                    // Reset local state when returning to lobby (e.g., after Play Again)
                    if (gameLoop) {
                        clearInterval(gameLoop);
                        gameLoop = null;
                    }
                    if (syncInterval) {
                        clearInterval(syncInterval);
                        syncInterval = null;
                    }

                    // Reset player state
                    isSpectating = false;
                    playerLives = 3;
                    lastHudState = { lives: -1, scores: '' };
                    window.mpGameStarted = false; // Allow game to start again
                    window.mpGameEnding = false; // Reset ending flag
                    window.mpGameStartTime = null; // Reset start time

                    // Hide game UI elements
                    mpHud.style.display = 'none';
                    gameOverEl.style.display = 'none';
                    const spectatingIndicator = document.getElementById('spectatingIndicator');
                    if (spectatingIndicator) spectatingIndicator.remove();
                    const spectatorLeaveBtn = document.getElementById('spectatorLeaveBtn');
                    if (spectatorLeaveBtn) spectatorLeaveBtn.remove();

                    // Remove waiting for host message if present
                    const waitingForHost = document.getElementById('waitingForHost');
                    if (waitingForHost) waitingForHost.remove();

                    // Remove last standing indicator if present
                    const lastStandingIndicator = document.getElementById('lastStandingIndicator');
                    if (lastStandingIndicator) lastStandingIndicator.remove();

                    // Hide results modal if showing
                    if (mpResultsModal) mpResultsModal.classList.remove('show');

                    // Update settings badges for non-host (in case host changed them)
                    if (!isHost) {
                        currentMode = gameData.mode;
                        currentSpeed = gameData.speed;
                        currentSize = gameData.mapSize;
                        obstaclesEnabled = gameData.obstacles;

                        // Update badge displays
                        lobbyMode.textContent = GAME_MODES[gameData.mode]?.name || gameData.mode;
                        lobbySpeed.textContent = gameData.speed.charAt(0).toUpperCase() + gameData.speed.slice(1);
                        lobbySize.textContent = gameData.mapSize.charAt(0).toUpperCase() + gameData.mapSize.slice(1);
                        const lobbyObstacles = document.getElementById('lobbyObstacles');
                        if (lobbyObstacles) {
                            lobbyObstacles.textContent = gameData.obstacles ? 'Obstacles On' : 'No Obstacles';
                        }
                    }

                    // Show lobby
                    updateLobbyPlayers(gameData.players);
                    showLobby(currentGameId, gameData);
                } else if (gameData.status === 'playing') {
                    // Game started - only initialize once
                    console.log('Status is playing, gameLoop:', gameLoop, 'mpGameStarted:', window.mpGameStarted);
                    if (!window.mpGameStarted) {
                        window.mpGameStarted = true;
                        mpLobbyModal.classList.remove('show');
                        startMultiplayerGame(gameData);
                    }
                } else if (gameData.status === 'finished') {
                    showMultiplayerResults(gameData);
                }

                // Update other players during gameplay
                if (isMultiplayer && gameData.status === 'playing') {
                    updateOtherPlayers(gameData.players);

                    // Sync food for ALL players (not just non-host)
                    // Only update if the food position actually changed
                    if (gameData.food && (food.x !== gameData.food.x || food.y !== gameData.food.y)) {
                        food = gameData.food;
                    }
                }
            }, (error) => {
                console.error('Listener error:', error);
            });
        }

        // Kick player (host only)
        async function kickPlayer(playerId) {
            if (!isHost || !currentGameId || !rtdb) return;

            try {
                await remove(ref(rtdb, `games/${currentGameId}/players/${playerId}`));
                console.log('Kicked player:', playerId);
            } catch (error) {
                console.error('Error kicking player:', error);
            }
        }

        // Make kickPlayer available globally for onclick
        window.kickPlayer = kickPlayer;

        // Host settings event handlers
        document.querySelectorAll('[data-mp-mode]').forEach(btn => {
            btn.addEventListener('click', async () => {
                if (!isHost || !currentGameId || !rtdb) return;
                const newMode = btn.dataset.mpMode;
                currentMode = newMode;
                document.querySelectorAll('[data-mp-mode]').forEach(b => b.classList.toggle('active', b.dataset.mpMode === newMode));
                await dbUpdate(ref(rtdb, `games/${currentGameId}`), { mode: newMode });
            });
        });

        document.querySelectorAll('[data-mp-speed]').forEach(btn => {
            btn.addEventListener('click', async () => {
                if (!isHost || !currentGameId || !rtdb) return;
                const newSpeed = btn.dataset.mpSpeed;
                currentSpeed = newSpeed;
                document.querySelectorAll('[data-mp-speed]').forEach(b => b.classList.toggle('active', b.dataset.mpSpeed === newSpeed));
                await dbUpdate(ref(rtdb, `games/${currentGameId}`), { speed: newSpeed });
            });
        });

        document.querySelectorAll('[data-mp-size]').forEach(btn => {
            btn.addEventListener('click', async () => {
                if (!isHost || !currentGameId || !rtdb) return;
                const newSize = btn.dataset.mpSize;
                currentSize = newSize;
                document.querySelectorAll('[data-mp-size]').forEach(b => b.classList.toggle('active', b.dataset.mpSize === newSize));
                await dbUpdate(ref(rtdb, `games/${currentGameId}`), { mapSize: newSize });
            });
        });

        document.querySelectorAll('[data-mp-obstacles]').forEach(btn => {
            btn.addEventListener('click', async () => {
                if (!isHost || !currentGameId || !rtdb) return;
                const newObstacles = btn.dataset.mpObstacles === 'true';
                obstaclesEnabled = newObstacles;
                document.querySelectorAll('[data-mp-obstacles]').forEach(b => b.classList.toggle('active', (b.dataset.mpObstacles === 'true') === newObstacles));
                await dbUpdate(ref(rtdb, `games/${currentGameId}`), { obstacles: newObstacles });
            });
        });

        // Leave multiplayer game
        async function leaveMultiplayerGame() {
            if (!currentGameId || !currentUser || !rtdb) return;

            try {
                // Remove player from game
                await remove(ref(rtdb, `games/${currentGameId}/players/${currentUser.uid}`));

                // If host, delete the entire game
                if (isHost) {
                    await remove(ref(rtdb, `games/${currentGameId}`));
                }

                // Clean up local state
                cleanupMultiplayer();

                // Reload to reset everything
                window.location.reload();
            } catch (error) {
                console.error('Error leaving game:', error);
                window.location.reload();
            }
        }

        // Make leaveMultiplayerGame available globally
        window.leaveMultiplayerGame = leaveMultiplayerGame;

        // Toggle ready status
        if (mpReadyBtn) {
            mpReadyBtn.addEventListener('click', async () => {
                if (!currentGameId || !currentUser || !rtdb) return;

                const playerRef = ref(rtdb, `games/${currentGameId}/players/${currentUser.uid}/ready`);
                const snapshot = await get(playerRef);
                const currentReady = snapshot.val() || false;

                await set(playerRef, !currentReady);

                mpReadyBtn.textContent = !currentReady ? 'Not Ready' : 'Ready';
                mpReadyBtn.classList.toggle('ready', !currentReady);
            });
        }

        // Start game (host only)
        if (mpStartBtn) {
            mpStartBtn.addEventListener('click', async () => {
                if (!currentGameId || !isHost || !rtdb) return;

                // Generate initial food position with random type
                const size = sizeSettings[currentSize];
                const initialFood = {
                    x: Math.floor(Math.random() * size.tiles),
                    y: Math.floor(Math.random() * size.tiles),
                    type: getRandomFoodType()
                };

                await dbUpdate(ref(rtdb, `games/${currentGameId}`), {
                    status: 'playing',
                    food: initialFood,
                    startedAt: Date.now()
                });
            });
        }

        // Leave room
        if (mpLeaveBtn) mpLeaveBtn.addEventListener('click', () => leaveRoom());
        if (mpLobbyClose) mpLobbyClose.addEventListener('click', () => leaveRoom());

        async function leaveRoom() {
            if (currentGameId && currentUser) {
                await remove(ref(rtdb, `games/${currentGameId}/players/${currentUser.uid}`));

                // If host leaves, delete the room
                if (isHost) {
                    await remove(ref(rtdb, `games/${currentGameId}`));
                }
            }
            closeLobby();
        }

        function closeLobby() {
            mpLobbyModal.classList.remove('show');
            if (gameStateListener) {
                gameStateListener();
                gameStateListener = null;
            }
            currentGameId = null;
            isHost = false;
            isMultiplayer = false;
            playerCount = 1;
            document.querySelectorAll('[data-players]').forEach(b => {
                b.classList.toggle('active', b.dataset.players === '1');
            });
            if (multiplayerControls) multiplayerControls.style.display = 'none';
        }

        // Copy room code
        if (copyRoomCode) {
            copyRoomCode.addEventListener('click', () => {
                navigator.clipboard.writeText(currentGameId);
                copyRoomCode.style.background = 'var(--primary)';
                setTimeout(() => copyRoomCode.style.background = '', 1000);
            });
        }

        // Copy room link
        if (copyRoomLink) {
            copyRoomLink.addEventListener('click', () => {
                const link = `${window.location.origin}${window.location.pathname}?room=${currentGameId}`;
                navigator.clipboard.writeText(link);
                copyRoomLink.style.background = 'var(--primary)';
                setTimeout(() => copyRoomLink.style.background = '', 1000);
            });
        }

        // Start multiplayer game
        function startMultiplayerGame(gameData) {
            console.log('Starting multiplayer game...');

            // Reset important state first
            isSpectating = false;
            playerLives = 3;
            isPaused = false;

            // Apply game settings
            currentMode = gameData.mode;
            currentSpeed = gameData.speed;
            currentSize = gameData.mapSize;
            obstaclesEnabled = gameData.obstacles;

            // Get my player data
            const myPlayer = gameData.players[currentUser.uid];
            if (myPlayer) {
                myPlayerColor = myPlayer.color;
                playerLives = myPlayer.lives || 3;
            }

            // Apply settings
            applySettings();

            // Reset HUD tracking state
            lastHudState = { lives: -1, scores: '', liveScores: '' };

            // Show live scores instead of high score in multiplayer
            if (highScoreDisplay) highScoreDisplay.style.display = 'none';
            if (mpLiveScores) mpLiveScores.style.display = 'flex';

            // Reset game timing and ending flags
            window.mpGameStartTime = Date.now();
            window.mpGameEnding = false;

            // Initialize the game (creates snake, resets score, etc.)
            init();

            // Show multiplayer HUD
            mpHud.style.display = 'flex';
            updateMpHud(gameData.players);

            // Clear any existing game loop and sync interval
            if (gameLoop) clearInterval(gameLoop);
            if (syncInterval) clearInterval(syncInterval);

            // Start the game loop
            gameLoop = setInterval(update, gameSpeed);

            // Start syncing state
            syncInterval = setInterval(() => syncLocalState(), SYNC_RATE);

            // Initialize other players
            updateOtherPlayers(gameData.players);

            // Set initial food from host
            if (gameData.food) {
                food = gameData.food;
            }

            // Hide game over screen if visible
            gameOverEl.style.display = 'none';

            // Force an initial draw to ensure canvas renders immediately
            draw();

            console.log('Multiplayer game started, snake:', snake.length, 'segments');
        }

        // Sync local state to Firebase
        async function syncLocalState() {
            if (!currentGameId || !currentUser || isSpectating) return;

            try {
                await dbUpdate(ref(rtdb, `games/${currentGameId}/players/${currentUser.uid}`), {
                    snake: snake,
                    direction: direction,
                    score: score,
                    lives: playerLives,
                    alive: playerLives > 0,
                    lastUpdate: Date.now()
                });
            } catch (error) {
                console.error('Sync error:', error);
            }
        }

        // Update other players data
        function updateOtherPlayers(players) {
            if (!players) return;

            otherPlayers = {};
            Object.entries(players).forEach(([playerId, playerData]) => {
                if (playerId !== currentUser.uid) {
                    otherPlayers[playerId] = playerData;
                }
            });

            updateMpHud(players);
            updateMpLiveScores(players);

            // Check win condition (only if game has been running for at least 2 seconds)
            const gameRunningTime = Date.now() - (window.mpGameStartTime || Date.now());
            if (gameRunningTime > 2000) {
                const alivePlayers = Object.entries(players).filter(([_, p]) => p.lives > 0);
                const deadPlayers = Object.entries(players).filter(([_, p]) => p.lives <= 0);
                const totalPlayers = Object.keys(players).length;

                // Show "Last One Standing" indicator when only 1 player remains
                if (alivePlayers.length === 1 && totalPlayers > 1) {
                    const lastStandingIndicator = document.getElementById('lastStandingIndicator');
                    if (!lastStandingIndicator && alivePlayers[0][0] === currentUser.uid) {
                        // Current player is the last one standing - show indicator
                        const indicator = document.createElement('div');
                        indicator.id = 'lastStandingIndicator';
                        indicator.style.cssText = 'position:fixed;top:120px;left:50%;transform:translateX(-50%);background:linear-gradient(135deg,#ffd700,#ff8c00);padding:10px 25px;border-radius:25px;color:#000;font-weight:bold;font-size:1rem;z-index:1000;animation:pulse 1s infinite;box-shadow:0 0 20px rgba(255,215,0,0.5);';
                        indicator.textContent = ' Last One Standing!';
                        document.body.appendChild(indicator);
                    }
                }

                // Game ends ONLY when ALL players are eliminated
                if (alivePlayers.length === 0 && totalPlayers > 1 && !window.mpGameEnding) {
                    window.mpGameEnding = true;
                    console.log('Game ending - all players eliminated');

                    // Remove last standing indicator if present
                    const lastStandingIndicator = document.getElementById('lastStandingIndicator');
                    if (lastStandingIndicator) lastStandingIndicator.remove();

                    if (isHost) {
                        dbUpdate(ref(rtdb, `games/${currentGameId}`), { status: 'finished' });
                    }
                }
            }
        }

        // Track last HUD state to prevent unnecessary updates
        let lastHudState = { lives: -1, scores: '', liveScores: '' };

        // Update live scores display in score-board (replaces high score in multiplayer)
        function updateMpLiveScores(players) {
            if (!players || !mpLiveScores) return;

            // Build a key to check if update is needed
            const liveScoresKey = Object.entries(players).map(([id, p]) => `${id}:${p.score}`).join(',');
            if (lastHudState.liveScores === liveScoresKey) return;
            lastHudState.liveScores = liveScoresKey;

            // Sort players by score (highest first)
            const sortedPlayers = Object.entries(players)
                .map(([id, p]) => ({ id, ...p }))
                .sort((a, b) => b.score - a.score);

            mpLiveScores.innerHTML = sortedPlayers.map(player => {
                const isMe = player.id === currentUser?.uid;
                return `
                    <div class="mp-live-score-item ${isMe ? 'me' : ''}" style="border-color: ${player.color}40;">
                        <div class="mp-live-score-color" style="background-color: ${player.color}; color: ${player.color};"></div>
                        <span class="mp-live-score-name">${isMe ? 'You' : player.name.slice(0, 8)}</span>
                        <span class="mp-live-score-value" style="color: ${player.color};">${player.score}</span>
                    </div>
                `;
            }).join('');
        }

        // Update multiplayer HUD (throttled)
        function updateMpHud(players) {
            if (!players) return;

            // Only update lives if changed
            if (lastHudState.lives !== playerLives) {
                lastHudState.lives = playerLives;
                mpLivesDisplay.innerHTML = '';
                for (let i = 0; i < 3; i++) {
                    const heart = document.createElement('span');
                    heart.className = `mp-life-heart ${i >= playerLives ? 'lost' : ''}`;
                    heart.textContent = '';
                    heart.style.color = myPlayerColor;
                    mpLivesDisplay.appendChild(heart);
                }
            }

            // Only update scores if changed
            const scoresKey = Object.entries(players).map(([id, p]) => `${id}:${p.score}:${p.lives}`).join(',');
            if (lastHudState.scores !== scoresKey) {
                lastHudState.scores = scoresKey;
                mpScoresDisplay.innerHTML = Object.entries(players).map(([playerId, player]) => `
                    <div class="mp-score-item ${player.lives <= 0 ? 'eliminated' : ''}">
                        <div class="mp-score-color" style="background-color: ${player.color};"></div>
                        <span class="mp-score-value">${player.score}</span>
                    </div>
                `).join('');
            }
        }

        // Handle multiplayer death
        async function handleMultiplayerDeath() {
            playerLives--;

            // Calculate points to give to survivors
            const pointsToGive = Math.floor(score / 2);

            // Update Firebase
            if (currentGameId && currentUser) {
                // Give points to other alive players
                const gameSnapshot = await get(ref(rtdb, `games/${currentGameId}`));
                const gameData = gameSnapshot.val();

                if (gameData && gameData.players) {
                    const alivePlayers = Object.entries(gameData.players)
                        .filter(([id, p]) => id !== currentUser.uid && p.lives > 0);

                    const pointsPerPlayer = Math.floor(pointsToGive / Math.max(alivePlayers.length, 1));

                    for (const [playerId, _] of alivePlayers) {
                        const currentScore = gameData.players[playerId].score || 0;
                        await dbUpdate(ref(rtdb, `games/${currentGameId}/players/${playerId}`), {
                            score: currentScore + pointsPerPlayer
                        });
                    }
                }

                // Update my state - save finalScore as highest score achieved
                const myCurrentFinalScore = gameData?.players?.[currentUser.uid]?.finalScore || 0;
                const newFinalScore = Math.max(myCurrentFinalScore, score);

                await dbUpdate(ref(rtdb, `games/${currentGameId}/players/${currentUser.uid}`), {
                    lives: playerLives,
                    score: 0,
                    finalScore: newFinalScore,
                    alive: playerLives > 0
                });
            }

            // Reset my score
            score = 0;

            if (playerLives > 0) {
                // Respawn
                respawnPlayer();
            } else {
                // Enter spectator mode
                enterSpectatorMode();
            }
        }

        // Respawn player
        function respawnPlayer() {
            const size = sizeSettings[currentSize];

            // Find safe spawn position
            let spawnX, spawnY;
            let attempts = 0;
            do {
                spawnX = Math.floor(Math.random() * (size.tiles - 4)) + 2;
                spawnY = Math.floor(Math.random() * (size.tiles - 4)) + 2;
                attempts++;
            } while (attempts < 50 && isPositionOccupied(spawnX, spawnY));

            // Reset snake
            snake = [];
            for (let i = 0; i < 3; i++) {
                snake.push({ x: spawnX - i, y: spawnY });
            }

            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };

            // Flash effect
            const wrapper = document.querySelector('.canvas-wrapper');
            wrapper.classList.add('shake');
            setTimeout(() => wrapper.classList.remove('shake'), 500);
        }

        // Check if position is occupied by other players
        function isPositionOccupied(x, y) {
            // Check other players' snakes
            for (const player of Object.values(otherPlayers)) {
                if (player.snake && player.snake.some(seg => seg.x === x && seg.y === y)) {
                    return true;
                }
            }
            // Check obstacles
            if (obstacles.some(obs => obs.x === x && obs.y === y)) {
                return true;
            }
            return false;
        }

        // Enter spectator mode
        function enterSpectatorMode() {
            isSpectating = true;

            // Stop syncing
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }

            // Show spectating indicator
            const indicator = document.createElement('div');
            indicator.className = 'spectating-indicator';
            indicator.id = 'spectatingIndicator';
            indicator.textContent = 'Spectating...';
            document.body.appendChild(indicator);

            // Add leave button for spectators
            const leaveBtn = document.createElement('button');
            leaveBtn.className = 'spectator-leave-btn';
            leaveBtn.id = 'spectatorLeaveBtn';
            leaveBtn.textContent = 'Leave Game';
            leaveBtn.onclick = leaveMultiplayerGame;
            document.body.appendChild(leaveBtn);

            // Clear snake
            snake = [];
        }

        // Cleanup multiplayer state
        function cleanupMultiplayer() {
            // Stop listeners
            if (gameStateListener) {
                gameStateListener();
                gameStateListener = null;
            }
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }
            if (gameLoop) {
                clearInterval(gameLoop);
                gameLoop = null;
            }

            // Remove spectator UI
            const spectatingIndicator = document.getElementById('spectatingIndicator');
            if (spectatingIndicator) spectatingIndicator.remove();
            const spectatorLeaveBtn = document.getElementById('spectatorLeaveBtn');
            if (spectatorLeaveBtn) spectatorLeaveBtn.remove();

            // Reset state
            isMultiplayer = false;
            currentGameId = null;
            isHost = false;
            isSpectating = false;
            otherPlayers = {};
            playerLives = 3;
            window.mpGameStarted = false;
            window.mpGameEnding = false;
            window.mpGameStartTime = null;

            // Remove waiting for host message if present
            const waitingForHost = document.getElementById('waitingForHost');
            if (waitingForHost) waitingForHost.remove();

            // Remove last standing indicator if present
            const lastStandingIndicator = document.getElementById('lastStandingIndicator');
            if (lastStandingIndicator) lastStandingIndicator.remove();

            // Restore high score display (hide live scores)
            if (highScoreDisplay) highScoreDisplay.style.display = '';
            if (mpLiveScores) {
                mpLiveScores.style.display = 'none';
                mpLiveScores.innerHTML = '';
            }
        }

        // Show multiplayer results
        function showMultiplayerResults(gameData) {
            // Stop game
            if (gameLoop) clearInterval(gameLoop);
            if (syncInterval) clearInterval(syncInterval);

            // Hide HUD and spectating UI
            mpHud.style.display = 'none';
            const spectatingIndicator = document.getElementById('spectatingIndicator');
            if (spectatingIndicator) spectatingIndicator.remove();
            const spectatorLeaveBtn = document.getElementById('spectatorLeaveBtn');
            if (spectatorLeaveBtn) spectatorLeaveBtn.remove();

            // Get rankings - use finalScore for display (persists after death)
            const players = Object.entries(gameData.players || {})
                .map(([id, p]) => ({ id, ...p, displayScore: p.finalScore || p.score || 0 }))
                .sort((a, b) => {
                    // Sort by finalScore (highest score achieved)
                    return b.displayScore - a.displayScore;
                });

            const winner = players[0];

            // Show winner
            mpResultsWinner.innerHTML = `
                <div class="winner-label">Winner</div>
                <div class="winner-name">${winner.name}</div>
            `;

            // Show rankings
            mpResultsRankings.innerHTML = players.map((player, index) => {
                const positionClass = index === 0 ? 'gold' : index === 1 ? 'silver' : 'bronze';
                return `
                    <div class="mp-ranking-item ${index === 0 ? 'first' : ''}">
                        <span class="mp-ranking-position ${positionClass}">#${index + 1}</span>
                        <span class="mp-ranking-name">${player.name}</span>
                        <span class="mp-ranking-score">${player.displayScore}</span>
                    </div>
                `;
            }).join('');

            mpResultsModal.classList.add('show');
        }

        // Results modal actions
        if (mpPlayAgain) {
            mpPlayAgain.addEventListener('click', async () => {
                window.scrollTo(0, 0);
                if (mpResultsModal) mpResultsModal.classList.remove('show');

                if (currentGameId && isHost && rtdb) {
                    // Host: Reset game state for everyone
                    const gameSnapshot = await get(ref(rtdb, `games/${currentGameId}`));
                    const gameData = gameSnapshot.val();

                    if (gameData) {
                        // Reset all players
                        const resetPlayers = {};
                        Object.entries(gameData.players).forEach(([playerId, player]) => {
                            resetPlayers[playerId] = {
                                ...player,
                                lives: 3,
                                score: 0,
                                snake: [],
                                alive: true,
                                ready: false
                            };
                        });

                        await dbUpdate(ref(rtdb, `games/${currentGameId}`), {
                            status: 'waiting',
                            players: resetPlayers
                        });
                    }

                    playerLives = 3;
                    isSpectating = false;
                    window.mpGameStarted = false;
                    // Lobby will be shown by the game state listener
                } else if (currentGameId && rtdb) {
                    // Non-host: Just wait for host to reset
                    // Reset local state in preparation
                    playerLives = 3;
                    isSpectating = false;
                    window.mpGameStarted = false;

                    // Remove spectator UI if present
                    const spectatingIndicator = document.getElementById('spectatingIndicator');
                    if (spectatingIndicator) spectatingIndicator.remove();
                    const spectatorLeaveBtn = document.getElementById('spectatorLeaveBtn');
                    if (spectatorLeaveBtn) spectatorLeaveBtn.remove();

                    // Show waiting message
                    const waitingDiv = document.createElement('div');
                    waitingDiv.id = 'waitingForHost';
                    waitingDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);padding:30px 50px;border-radius:15px;color:#00ff88;font-size:1.2rem;z-index:10000;text-align:center;border:2px solid #00ff88;';
                    waitingDiv.innerHTML = '<div style="margin-bottom:10px;"></div>Waiting for host to start...';
                    document.body.appendChild(waitingDiv);

                    // The game state listener will handle showing the lobby when host resets
                } else {
                    closeLobby();
                }
            });
        }

        if (mpExitResults) {
            mpExitResults.addEventListener('click', () => {
                if (mpResultsModal) mpResultsModal.classList.remove('show');
                leaveRoom();
            });
        }

        // Handle food collision in multiplayer (any player can trigger new food)
        async function handleMultiplayerFoodCollision() {
            if (!currentGameId || !rtdb) return;

            // Generate new food at random position with random type
            const size = sizeSettings[currentSize];
            let newFood;
            let attempts = 0;

            do {
                newFood = {
                    x: Math.floor(Math.random() * size.tiles),
                    y: Math.floor(Math.random() * size.tiles),
                    type: getRandomFoodType()
                };
                attempts++;
            } while (attempts < 50 && (
                snake.some(seg => seg.x === newFood.x && seg.y === newFood.y) ||
                isPositionOccupied(newFood.x, newFood.y)
            ));

            // Don't update local food here - let Firebase sync handle it for both players
            // This ensures both players see the same food

            // Update food in Firebase (any player can do this)
            try {
                await dbUpdate(ref(rtdb, `games/${currentGameId}`), { food: newFood });
            } catch (error) {
                console.error('Error updating food:', error);
            }
        }

        function getRandomFoodType() {
            const rand = Math.random();
            if (rand < 0.6) return 'apple';
            if (rand < 0.8) return 'cherry';
            if (rand < 0.9) return 'golden';
            return 'rotten';
        }

        // Check for room code in URL on load
        function checkUrlForRoom() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');

            if (roomCode && currentUser) {
                // Wait a bit for everything to initialize
                setTimeout(() => {
                    playerCount = 2;
                    isMultiplayer = true;
                    document.querySelectorAll('[data-players]').forEach(b => {
                        b.classList.toggle('active', b.dataset.players === '2');
                    });
                    multiplayerControls.style.display = 'block';
                    joinMultiplayerRoom(roomCode.toUpperCase());
                }, 500);
            }
        }

        // Start
        applySettings();
        init();

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
