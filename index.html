<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
        }

        .main-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .game-container {
            text-align: center;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            min-height: 50px;
        }

        h1 {
            color: #00ff88;
            font-size: 2.5rem;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #00ff88;
        }

        .user-name {
            color: #fff;
            font-size: 0.9rem;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .auth-btn {
            background: #00ff88;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            font-size: 0.9rem;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .auth-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .auth-btn.sign-out {
            background: transparent;
            border: 1px solid #ff0055;
            color: #ff0055;
            padding: 6px 12px;
            font-size: 0.8rem;
        }

        .auth-btn.sign-out:hover {
            background: #ff0055;
            color: #fff;
        }

        .google-icon {
            width: 18px;
            height: 18px;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 10px;
        }

        .score, .high-score {
            color: #fff;
            font-size: 1.2rem;
        }

        .score span, .high-score span {
            color: #00ff88;
            font-weight: bold;
        }

        .timer {
            color: #fff;
            font-size: 1.2rem;
        }

        .timer span {
            color: #ff6600;
            font-weight: bold;
        }

        .timer.urgent span {
            color: #ff0055;
            animation: pulse 0.5s infinite;
        }

        .mode-indicator {
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 8px;
            min-height: 20px;
        }

        .mode-indicator span {
            color: #00ff88;
            font-weight: bold;
        }

        .mode-options {
            flex-wrap: wrap;
        }

        .mode-options .setting-btn {
            min-width: 45%;
        }

        /* Combo Display */
        .combo-display {
            min-height: 30px;
            margin-bottom: 5px;
            text-align: center;
        }

        .combo-text {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            animation: combo-pop 0.3s ease;
        }

        .combo-text.combo-1 { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .combo-text.combo-2 { background: rgba(255, 215, 0, 0.2); color: #ffd700; font-size: 1.1rem; }
        .combo-text.combo-3 { background: rgba(255, 165, 0, 0.3); color: #ffa500; font-size: 1.2rem; }
        .combo-text.combo-4 { background: rgba(255, 69, 0, 0.3); color: #ff4500; font-size: 1.3rem; }
        .combo-text.combo-5 { background: rgba(255, 0, 85, 0.4); color: #ff0055; font-size: 1.4rem; text-shadow: 0 0 10px #ff0055; }

        @keyframes combo-pop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .combo-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .combo-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #ffd700);
            transition: width 0.1s linear;
        }

        /* Active Power-ups Display */
        .active-powerups {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            min-height: 30px;
            flex-wrap: wrap;
        }

        .powerup-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        .powerup-indicator.speed { background: rgba(0, 150, 255, 0.3); color: #00aaff; border: 1px solid #00aaff; }
        .powerup-indicator.shield { background: rgba(0, 255, 255, 0.3); color: #00ffff; border: 1px solid #00ffff; }
        .powerup-indicator.double { background: rgba(255, 215, 0, 0.3); color: #ffd700; border: 1px solid #ffd700; }
        .powerup-indicator.slow { background: rgba(180, 0, 255, 0.3); color: #b400ff; border: 1px solid #b400ff; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes shake {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-8px, -6px) rotate(-1deg); }
            20% { transform: translate(8px, -4px) rotate(1deg); }
            30% { transform: translate(-6px, 8px) rotate(0deg); }
            40% { transform: translate(6px, 6px) rotate(1deg); }
            50% { transform: translate(-4px, -8px) rotate(-1deg); }
            60% { transform: translate(4px, 4px) rotate(0deg); }
            70% { transform: translate(-8px, 2px) rotate(-1deg); }
            80% { transform: translate(6px, -4px) rotate(1deg); }
            90% { transform: translate(-2px, 6px) rotate(0deg); }
        }

        @keyframes flash-red {
            0%, 100% { border-color: #00ff88; box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); }
            50% { border-color: #ff0055; box-shadow: 0 0 50px rgba(255, 0, 85, 0.8); }
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        .canvas-wrapper.shake {
            animation: shake 0.5s ease-in-out;
        }

        canvas {
            border: 3px solid #00ff88;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            background: #0a0a15;
            display: block;
            transition: border-color 0.1s, box-shadow 0.1s;
        }

        canvas.flash {
            animation: flash-red 0.15s ease-in-out 3;
        }

        .controls {
            margin-top: 20px;
            color: #888;
            font-size: 0.9rem;
        }

        .controls p {
            margin: 5px 0;
        }

        /* Side Panel */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Leaderboard, Settings & Daily Challenge */
        .leaderboard, .settings, .daily-challenge {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 20px;
            min-width: 250px;
        }

        .daily-challenge {
            border-color: #ff6600;
        }

        .daily-challenge h2 {
            color: #ff6600;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
        }

        .challenge-desc {
            color: #fff;
            font-size: 1rem;
            margin-bottom: 12px;
            text-align: center;
        }

        .challenge-desc .challenge-type {
            color: #ff6600;
            font-weight: bold;
        }

        .challenge-progress {
            margin-bottom: 10px;
        }

        .challenge-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .challenge-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffd700);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .challenge-status {
            color: #888;
            font-size: 0.85rem;
            display: block;
            text-align: center;
        }

        .challenge-status.completed {
            color: #00ff88;
            font-weight: bold;
        }

        .challenge-reward {
            text-align: center;
            font-size: 0.9rem;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .challenge-reward .streak {
            color: #ffd700;
            font-weight: bold;
        }

        .leaderboard h2, .settings h2 {
            color: #00ff88;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .leaderboard-list {
            list-style: none;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s ease;
        }

        .leaderboard-item:hover {
            background: rgba(0, 255, 136, 0.1);
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-item.current-user {
            background: rgba(0, 255, 136, 0.15);
            border-radius: 8px;
        }

        .rank {
            font-size: 1.1rem;
            font-weight: bold;
            width: 30px;
            text-align: center;
        }

        .rank.gold { color: #ffd700; }
        .rank.silver { color: #c0c0c0; }
        .rank.bronze { color: #cd7f32; }
        .rank.normal { color: #888; }

        .player-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .player-info {
            flex: 1;
            overflow: hidden;
        }

        .player-name {
            color: #fff;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-score {
            color: #00ff88;
            font-weight: bold;
            font-size: 1rem;
        }

        .no-scores {
            color: #888;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }

        .loading {
            color: #888;
            text-align: center;
            padding: 20px;
        }

        /* Settings */
        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            color: #fff;
            font-size: 0.9rem;
            margin-bottom: 8px;
            display: block;
        }

        .setting-options {
            display: flex;
            gap: 8px;
        }

        .setting-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            color: #888;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
        }

        .setting-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #fff;
        }

        .setting-btn.active {
            background: #00ff88;
            border-color: #00ff88;
            color: #1a1a2e;
            font-weight: bold;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid #444;
        }

        .toggle.active {
            background: #00ff88;
            border-color: #00ff88;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle.active::after {
            left: 27px;
            background: #1a1a2e;
        }

        .apply-btn {
            width: 100%;
            padding: 12px;
            background: #00ff88;
            border: none;
            color: #1a1a2e;
            font-weight: bold;
            font-size: 1rem;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .apply-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .settings-note {
            color: #666;
            font-size: 0.75rem;
            text-align: center;
            margin-top: 10px;
        }

        /* Skin Selector */
        .skin-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .skin-btn {
            width: 100%;
            aspect-ratio: 1;
            padding: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #444;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .skin-btn:hover {
            transform: scale(1.1);
            border-color: #888;
        }

        .skin-btn.active {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .skin-preview {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 6px;
        }

        /* Power-up Legend */
        .powerup-legend {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .powerup-legend h3 {
            color: #00ff88;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.8rem;
            color: #888;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.speed { background: #00aaff; }
        .legend-dot.shield { background: #00ffff; }
        .legend-dot.double { background: #ffd700; }
        .legend-dot.slow { background: #b400ff; }

        /* Game Over Modal */
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            border: 2px solid #ff0055;
            display: none;
            z-index: 100;
            text-align: center;
        }

        .game-over h2 {
            color: #ff0055;
            font-size: 2rem;
            margin-bottom: 15px;
        }

        .game-over p {
            color: #fff;
            margin-bottom: 10px;
        }

        .game-over .new-record {
            color: #ffd700;
            font-size: 1.2rem;
            margin-bottom: 15px;
        }

        .restart-btn {
            background: #00ff88;
            color: #1a1a2e;
            border: none;
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #2d1f4e 100%);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.5s ease;
            z-index: 200;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .achievement-popup.show {
            transform: translateX(0);
            opacity: 1;
        }

        .achievement-icon {
            font-size: 2.5rem;
            animation: bounce 0.5s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .achievement-title {
            color: #ffd700;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .achievement-name {
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
        }

        /* Achievements Toggle Button */
        .achievements-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ffd700;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 150;
        }

        .achievements-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        /* Achievements Panel */
        .achievements-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            width: 300px;
            max-height: 70vh;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 15px;
            display: none;
            z-index: 150;
            overflow-y: auto;
        }

        .achievements-panel.show {
            display: block;
        }

        .achievements-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }

        .achievements-header h3 {
            color: #ffd700;
            margin: 0;
        }

        .achievements-close {
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.2s;
        }

        .achievements-close:hover {
            color: #fff;
        }

        .achievement-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.2s ease;
        }

        .achievement-item.locked {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .achievement-item.unlocked {
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .achievement-item-icon {
            font-size: 1.8rem;
            min-width: 40px;
            text-align: center;
        }

        .achievement-item-info {
            flex: 1;
        }

        .achievement-item-name {
            color: #fff;
            font-size: 0.95rem;
            font-weight: bold;
        }

        .achievement-item-desc {
            color: #888;
            font-size: 0.8rem;
        }

        .achievement-item-status {
            color: #ffd700;
            font-size: 0.75rem;
        }

        /* Mobile */
        .mobile-controls {
            display: none;
            margin-top: 20px;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            border-radius: 10px;
            color: #00ff88;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mobile-btn:active {
            background: #00ff88;
            color: #1a1a2e;
        }

        .btn-row {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .side-panel {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .leaderboard, .settings {
                width: 100%;
                max-width: 350px;
            }
        }

        @media (max-width: 500px) {
            .mobile-controls {
                display: block;
            }

            .controls {
                display: none;
            }

            h1 {
                font-size: 1.8rem;
            }

            .header {
                flex-direction: column;
                gap: 10px;
            }

            .setting-options {
                flex-wrap: wrap;
            }

            .setting-btn {
                min-width: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="game-container">
            <div class="header">
                <h1>SNAKE</h1>
                <div id="authContainer">
                    <button class="auth-btn" id="signInBtn" onclick="signIn()">
                        <svg class="google-icon" viewBox="0 0 24 24">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        Sign in with Google
                    </button>
                </div>
            </div>
            <div class="score-board">
                <div class="score">Score: <span id="score">0</span></div>
                <div class="timer" id="timerDisplay" style="display: none;">Time: <span id="timer">60</span>s</div>
                <div class="high-score">Your Best: <span id="highScore">0</span></div>
            </div>
            <div class="mode-indicator" id="modeIndicator"></div>
            <div class="combo-display" id="comboDisplay"></div>
            <div class="active-powerups" id="activePowerups"></div>
            <div class="canvas-wrapper">
                <canvas id="gameCanvas" width="400" height="400"></canvas>
            </div>
            <div class="controls">
                <p>Use Arrow Keys or WASD to move</p>
                <p>Press Space to pause</p>
            </div>
            <div class="mobile-controls">
                <div class="btn-row">
                    <button class="mobile-btn" id="upBtn">&#9650;</button>
                </div>
                <div class="btn-row">
                    <button class="mobile-btn" id="leftBtn">&#9664;</button>
                    <button class="mobile-btn" id="downBtn">&#9660;</button>
                    <button class="mobile-btn" id="rightBtn">&#9654;</button>
                </div>
            </div>
        </div>

        <div class="side-panel">
            <div class="settings">
                <h2>Settings</h2>

                <div class="setting-group">
                    <label class="setting-label">Game Mode</label>
                    <div class="setting-options mode-options">
                        <button class="setting-btn active" data-mode="classic" title="Standard snake game">Classic</button>
                        <button class="setting-btn" data-mode="timeattack" title="60 seconds to get highest score">Time Attack</button>
                        <button class="setting-btn" data-mode="nowalls" title="Pass through walls">No Walls</button>
                        <button class="setting-btn" data-mode="zen" title="Relaxing mode, no death">Zen</button>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Speed</label>
                    <div class="setting-options">
                        <button class="setting-btn" data-speed="slow">Slow</button>
                        <button class="setting-btn active" data-speed="normal">Normal</button>
                        <button class="setting-btn" data-speed="fast">Fast</button>
                        <button class="setting-btn" data-speed="insane">Insane</button>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Map Size</label>
                    <div class="setting-options">
                        <button class="setting-btn" data-size="small">Small</button>
                        <button class="setting-btn active" data-size="medium">Medium</button>
                        <button class="setting-btn" data-size="large">Large</button>
                    </div>
                </div>

                <div class="setting-group">
                    <div class="toggle-container">
                        <label class="setting-label" style="margin-bottom: 0;">Obstacles</label>
                        <div class="toggle" id="obstaclesToggle"></div>
                    </div>
                </div>

                <div class="setting-group">
                    <div class="toggle-container">
                        <label class="setting-label" style="margin-bottom: 0;">Sound Effects</label>
                        <div class="toggle active" id="soundToggle"></div>
                    </div>
                </div>

                <button class="apply-btn" id="applySettings">Apply & Restart</button>
                <p class="settings-note">Changes require game restart</p>

                <div class="setting-group">
                    <label class="setting-label">Snake Skin</label>
                    <div class="skin-options">
                        <button class="skin-btn active" data-skin="neon" title="Neon Green">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #00ff88, #00cc6a)"></span>
                        </button>
                        <button class="skin-btn" data-skin="fire" title="Fire">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #ff4400, #ffaa00)"></span>
                        </button>
                        <button class="skin-btn" data-skin="ice" title="Ice">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #00bfff, #e0ffff)"></span>
                        </button>
                        <button class="skin-btn" data-skin="purple" title="Purple Haze">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #9b59b6, #e056fd)"></span>
                        </button>
                        <button class="skin-btn" data-skin="gold" title="Golden">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #ffd700, #ffec8b)"></span>
                        </button>
                        <button class="skin-btn" data-skin="rainbow" title="Rainbow">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #8b00ff)"></span>
                        </button>
                        <button class="skin-btn" data-skin="stealth" title="Stealth">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #2c3e50, #34495e)"></span>
                        </button>
                        <button class="skin-btn" data-skin="candy" title="Candy">
                            <span class="skin-preview" style="background: linear-gradient(135deg, #ff69b4, #ff1493)"></span>
                        </button>
                    </div>
                </div>

                <div class="powerup-legend">
                    <h3>Food Types</h3>
                    <div class="legend-item"><span class="legend-dot" style="background:#ff0055"></span> Apple (+10 pts)</div>
                    <div class="legend-item"><span class="legend-dot" style="background:#ffd700"></span> Golden (+50 pts)</div>
                    <div class="legend-item"><span class="legend-dot" style="background:#ff66aa"></span> Cherry (+20, grow x2)</div>
                    <div class="legend-item"><span class="legend-dot" style="background:#8b4513"></span> Rotten (-10, shrink)</div>
                </div>

                <div class="powerup-legend">
                    <h3>Power-ups</h3>
                    <div class="legend-item"><span class="legend-dot speed"></span> Speed Boost</div>
                    <div class="legend-item"><span class="legend-dot shield"></span> Shield (Invincible)</div>
                    <div class="legend-item"><span class="legend-dot double"></span> 2x Score</div>
                    <div class="legend-item"><span class="legend-dot slow"></span> Slow Motion</div>
                </div>
            </div>

            <div class="daily-challenge">
                <h2>Daily Challenge</h2>
                <div class="challenge-content" id="challengeContent">
                    <div class="challenge-desc" id="challengeDesc"></div>
                    <div class="challenge-progress">
                        <div class="challenge-bar">
                            <div class="challenge-bar-fill" id="challengeBarFill"></div>
                        </div>
                        <span class="challenge-status" id="challengeStatus"></span>
                    </div>
                    <div class="challenge-reward" id="challengeReward"></div>
                </div>
            </div>

            <div class="leaderboard">
                <h2>Global Leaderboard</h2>
                <ul class="leaderboard-list" id="leaderboardList">
                    <li class="loading">Loading...</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p class="new-record" id="newRecord" style="display: none;">New Personal Best!</p>
        <button class="restart-btn" id="restartBtn">Play Again</button>
    </div>

    <!-- Achievement Popup -->
    <div class="achievement-popup" id="achievementPopup">
        <div class="achievement-icon">üèÜ</div>
        <div class="achievement-info">
            <div class="achievement-title">Achievement Unlocked!</div>
            <div class="achievement-name" id="achievementName"></div>
        </div>
    </div>

    <!-- Achievements Panel (toggleable) -->
    <button class="achievements-toggle" id="achievementsToggle">üèÜ</button>
    <div class="achievements-panel" id="achievementsPanel">
        <div class="achievements-header">
            <h3>Achievements</h3>
            <span class="achievements-close" id="achievementsClose">&times;</span>
        </div>
        <div class="achievements-list" id="achievementsList"></div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, where, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyBX1h3arCxEBsX3hlYJKDK6k2grnJkru1I",
            authDomain: "snake-3e4dc.firebaseapp.com",
            projectId: "snake-3e4dc",
            storageBucket: "snake-3e4dc.firebasestorage.app",
            messagingSenderId: "503723147324",
            appId: "1:503723147324:web:46ba9ef5f034c831904339"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();

        // Game elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const newRecordEl = document.getElementById('newRecord');
        const authContainer = document.getElementById('authContainer');
        const leaderboardList = document.getElementById('leaderboardList');
        const activePowerupsEl = document.getElementById('activePowerups');

        // Settings
        const speedSettings = { slow: 150, normal: 100, fast: 60, insane: 35 };
        const sizeSettings = { small: { tiles: 15, pixels: 300 }, medium: { tiles: 20, pixels: 400 }, large: { tiles: 25, pixels: 500 } };

        let currentSpeed = 'normal';
        let currentSize = 'medium';
        let obstaclesEnabled = false;
        let obstacles = [];
        let currentSkin = 'neon';
        let currentMode = 'classic';
        let timeLeft = 60;
        let timerInterval = null;

        // Game modes configuration
        const GAME_MODES = {
            classic: {
                name: 'Classic',
                description: 'Standard snake game',
                hasTimer: false,
                noWalls: false,
                noDeath: false
            },
            timeattack: {
                name: 'Time Attack',
                description: '60 seconds to score!',
                hasTimer: true,
                timerDuration: 60,
                noWalls: false,
                noDeath: false
            },
            nowalls: {
                name: 'No Walls',
                description: 'Pass through walls',
                hasTimer: false,
                noWalls: true,
                noDeath: false
            },
            zen: {
                name: 'Zen Mode',
                description: 'Relax, no death',
                hasTimer: false,
                noWalls: true,
                noDeath: true
            }
        };

        // Snake skins configuration
        const SNAKE_SKINS = {
            neon: {
                primary: '#00ff88',
                secondary: '#00cc6a',
                glow: '#00ff88',
                eye: '#1a1a2e'
            },
            fire: {
                primary: '#ff4400',
                secondary: '#ffaa00',
                glow: '#ff6600',
                eye: '#1a1a2e'
            },
            ice: {
                primary: '#00bfff',
                secondary: '#e0ffff',
                glow: '#00d4ff',
                eye: '#1a1a2e'
            },
            purple: {
                primary: '#9b59b6',
                secondary: '#e056fd',
                glow: '#b866e0',
                eye: '#1a1a2e'
            },
            gold: {
                primary: '#ffd700',
                secondary: '#ffec8b',
                glow: '#ffdf00',
                eye: '#1a1a2e'
            },
            rainbow: {
                primary: 'rainbow', // Special flag for rainbow effect
                secondary: 'rainbow',
                glow: '#ffffff',
                eye: '#1a1a2e'
            },
            stealth: {
                primary: '#2c3e50',
                secondary: '#34495e',
                glow: '#3d566e',
                eye: '#00ff88'
            },
            candy: {
                primary: '#ff69b4',
                secondary: '#ff1493',
                glow: '#ff69b4',
                eye: '#1a1a2e'
            }
        };

        // Game variables
        let gridSize = 20;
        let tileCount = 20;
        let snake = [];
        let food = {};
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let score = 0;
        let personalBest = 0;
        let gameLoop;
        let isPaused = false;
        let gameSpeed = 100;
        let baseSpeed = 100;
        let currentUser = null;

        // Food types system
        const FOOD_TYPES = {
            apple: { color: '#ff0055', points: 10, grow: 1, chance: 60 },
            golden: { color: '#ffd700', points: 50, grow: 1, chance: 10 },
            cherry: { color: '#ff66aa', points: 20, grow: 2, chance: 20 },
            rotten: { color: '#8b4513', points: -10, grow: -1, chance: 10 }
        };

        // Power-up system
        const POWERUP_TYPES = {
            speed: { color: '#00aaff', name: 'Speed Boost', duration: 5000 },
            shield: { color: '#00ffff', name: 'Shield', duration: 5000 },
            double: { color: '#ffd700', name: '2x Score', duration: 8000 },
            slow: { color: '#b400ff', name: 'Slow Motion', duration: 6000 }
        };

        let powerup = null;
        let activePowerups = {
            speed: { active: false, endTime: 0 },
            shield: { active: false, endTime: 0 },
            double: { active: false, endTime: 0 },
            slow: { active: false, endTime: 0 }
        };

        let scoreMultiplier = 1;
        let lastPowerupSpawn = 0;
        const POWERUP_SPAWN_INTERVAL = 10000; // Spawn every 10 seconds

        // Achievements System
        const ACHIEVEMENTS = {
            first_food: { name: 'First Bite', desc: 'Eat your first food', icon: 'üçé' },
            score_50: { name: 'Getting Started', desc: 'Score 50 points', icon: '‚≠ê' },
            score_100: { name: 'Century', desc: 'Score 100 points', icon: 'üíØ' },
            score_250: { name: 'Quarter Master', desc: 'Score 250 points', icon: 'üèÖ' },
            score_500: { name: 'Half Grand', desc: 'Score 500 points', icon: 'ü•à' },
            score_1000: { name: 'Grand Master', desc: 'Score 1000 points', icon: 'ü•á' },
            length_10: { name: 'Growing Up', desc: 'Reach length 10', icon: 'üìè' },
            length_20: { name: 'Long Boi', desc: 'Reach length 20', icon: 'üêç' },
            length_50: { name: 'Mega Snake', desc: 'Reach length 50', icon: 'üêâ' },
            golden_catch: { name: 'Gold Digger', desc: 'Eat a golden apple', icon: 'üí∞' },
            powerup_collect: { name: 'Powered Up', desc: 'Collect a power-up', icon: '‚ö°' },
            survive_60: { name: 'Survivor', desc: 'Survive 60 seconds', icon: '‚è±Ô∏è' },
            no_walls: { name: 'Wall Walker', desc: 'Play No Walls mode', icon: 'üö™' },
            time_attack: { name: 'Speed Demon', desc: 'Play Time Attack mode', icon: 'üèÉ' },
            zen_master: { name: 'Zen Master', desc: 'Play Zen mode', icon: 'üßò' },
            skin_change: { name: 'Fashionista', desc: 'Change your skin', icon: 'üé®' }
        };

        let unlockedAchievements = JSON.parse(localStorage.getItem('snakeAchievements') || '[]');
        let gameStartTime = Date.now();
        let totalFoodEaten = 0;
        let achievementQueue = [];
        let showingAchievement = false;

        // Combo System
        let combo = 0;
        let lastFoodTime = 0;
        const COMBO_TIMEOUT = 3000; // 3 seconds to maintain combo
        const COMBO_MULTIPLIERS = [1, 1.2, 1.5, 2, 2.5, 3]; // Multipliers for combo levels

        function updateComboDisplay() {
            const comboDisplay = document.getElementById('comboDisplay');
            const timeSinceFood = Date.now() - lastFoodTime;
            const timeRemaining = Math.max(0, COMBO_TIMEOUT - timeSinceFood);

            if (combo > 0 && timeRemaining > 0) {
                const comboLevel = Math.min(combo, 5);
                const multiplier = COMBO_MULTIPLIERS[Math.min(combo, COMBO_MULTIPLIERS.length - 1)];
                comboDisplay.innerHTML = `
                    <span class="combo-text combo-${comboLevel}">
                        ${combo}x COMBO! (${multiplier}x points)
                    </span>
                    <div class="combo-bar">
                        <div class="combo-bar-fill" style="width: ${(timeRemaining / COMBO_TIMEOUT) * 100}%"></div>
                    </div>
                `;
            } else if (combo > 0 && timeRemaining <= 0) {
                combo = 0;
                comboDisplay.innerHTML = '';
            } else {
                comboDisplay.innerHTML = '';
            }
        }

        function addCombo() {
            const now = Date.now();
            if (now - lastFoodTime <= COMBO_TIMEOUT) {
                combo++;
            } else {
                combo = 1;
            }
            lastFoodTime = now;
            return COMBO_MULTIPLIERS[Math.min(combo, COMBO_MULTIPLIERS.length - 1)];
        }

        // Daily Challenge System
        const DAILY_CHALLENGES = [
            { type: 'score', target: 100, desc: 'Score 100 points' },
            { type: 'score', target: 200, desc: 'Score 200 points' },
            { type: 'score', target: 300, desc: 'Score 300 points' },
            { type: 'length', target: 15, desc: 'Reach length 15' },
            { type: 'length', target: 20, desc: 'Reach length 20' },
            { type: 'combo', target: 5, desc: 'Get a 5x combo' },
            { type: 'golden', target: 3, desc: 'Eat 3 golden apples' },
            { type: 'food', target: 20, desc: 'Eat 20 pieces of food' },
            { type: 'timeattack', target: 150, desc: 'Score 150 in Time Attack' },
            { type: 'nowalls', target: 100, desc: 'Score 100 in No Walls mode' }
        ];

        let dailyChallenge = null;
        let dailyChallengeProgress = 0;
        let dailyChallengeCompleted = false;
        let dailyStreak = parseInt(localStorage.getItem('dailyStreak') || '0');
        let goldenEatenToday = 0;

        function getDailyChallenge() {
            const today = new Date().toDateString();
            const storedDate = localStorage.getItem('dailyChallengeDate');

            if (storedDate !== today) {
                // New day, generate new challenge
                const seed = hashCode(today);
                const challengeIndex = Math.abs(seed) % DAILY_CHALLENGES.length;
                dailyChallenge = DAILY_CHALLENGES[challengeIndex];
                dailyChallengeProgress = 0;
                dailyChallengeCompleted = false;
                goldenEatenToday = 0;

                localStorage.setItem('dailyChallengeDate', today);
                localStorage.setItem('dailyChallengeIndex', challengeIndex);
                localStorage.setItem('dailyChallengeCompleted', 'false');
            } else {
                // Same day, restore challenge
                const challengeIndex = parseInt(localStorage.getItem('dailyChallengeIndex') || '0');
                dailyChallenge = DAILY_CHALLENGES[challengeIndex];
                dailyChallengeCompleted = localStorage.getItem('dailyChallengeCompleted') === 'true';
            }

            updateDailyChallengeDisplay();
        }

        function hashCode(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash;
        }

        function updateDailyChallengeProgress(type, value) {
            if (dailyChallengeCompleted || !dailyChallenge) return;

            if (dailyChallenge.type === type) {
                if (type === 'combo' || type === 'golden') {
                    dailyChallengeProgress = Math.max(dailyChallengeProgress, value);
                } else {
                    dailyChallengeProgress = value;
                }

                if (dailyChallengeProgress >= dailyChallenge.target) {
                    completeDailyChallenge();
                }

                updateDailyChallengeDisplay();
            }

            // Special handling for mode-specific challenges
            if ((dailyChallenge.type === 'timeattack' && currentMode === 'timeattack' && type === 'score') ||
                (dailyChallenge.type === 'nowalls' && currentMode === 'nowalls' && type === 'score')) {
                dailyChallengeProgress = value;
                if (dailyChallengeProgress >= dailyChallenge.target) {
                    completeDailyChallenge();
                }
                updateDailyChallengeDisplay();
            }
        }

        function completeDailyChallenge() {
            if (dailyChallengeCompleted) return;

            dailyChallengeCompleted = true;
            localStorage.setItem('dailyChallengeCompleted', 'true');

            // Update streak
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const lastCompletion = localStorage.getItem('lastChallengeCompletion');

            if (lastCompletion === yesterday.toDateString()) {
                dailyStreak++;
            } else if (lastCompletion !== new Date().toDateString()) {
                dailyStreak = 1;
            }

            localStorage.setItem('dailyStreak', dailyStreak);
            localStorage.setItem('lastChallengeCompletion', new Date().toDateString());

            // Show achievement-style popup
            showAchievementPopup('daily_complete');
            updateDailyChallengeDisplay();
        }

        function updateDailyChallengeDisplay() {
            if (!dailyChallenge) return;

            const descEl = document.getElementById('challengeDesc');
            const barFill = document.getElementById('challengeBarFill');
            const statusEl = document.getElementById('challengeStatus');
            const rewardEl = document.getElementById('challengeReward');

            descEl.innerHTML = `<span class="challenge-type">${dailyChallenge.desc}</span>`;

            const progress = Math.min(dailyChallengeProgress / dailyChallenge.target * 100, 100);
            barFill.style.width = `${progress}%`;

            if (dailyChallengeCompleted) {
                statusEl.textContent = '‚úì Completed!';
                statusEl.className = 'challenge-status completed';
            } else {
                statusEl.textContent = `${dailyChallengeProgress} / ${dailyChallenge.target}`;
                statusEl.className = 'challenge-status';
            }

            rewardEl.innerHTML = dailyStreak > 0
                ? `üî• <span class="streak">${dailyStreak} day streak!</span>`
                : 'Complete for streak bonus!';
        }

        // Add daily_complete to achievements
        ACHIEVEMENTS.daily_complete = { name: 'Daily Grind', desc: 'Complete a daily challenge', icon: 'üìÖ' };

        // Initialize daily challenge
        getDailyChallenge();

        function checkAchievement(id) {
            if (unlockedAchievements.includes(id)) return false;
            unlockedAchievements.push(id);
            localStorage.setItem('snakeAchievements', JSON.stringify(unlockedAchievements));
            showAchievementPopup(id);
            updateAchievementsList();
            return true;
        }

        function showAchievementPopup(id) {
            achievementQueue.push(id);
            processAchievementQueue();
        }

        function processAchievementQueue() {
            if (showingAchievement || achievementQueue.length === 0) return;

            showingAchievement = true;
            const id = achievementQueue.shift();
            const achievement = ACHIEVEMENTS[id];
            const popup = document.getElementById('achievementPopup');
            const nameEl = document.getElementById('achievementName');

            nameEl.textContent = achievement.name;
            document.querySelector('.achievement-icon').textContent = achievement.icon;
            popup.classList.add('show');

            setTimeout(() => {
                popup.classList.remove('show');
                setTimeout(() => {
                    showingAchievement = false;
                    processAchievementQueue();
                }, 500);
            }, 3000);
        }

        function updateAchievementsList() {
            const list = document.getElementById('achievementsList');
            list.innerHTML = '';

            const unlockedCount = unlockedAchievements.length;
            const totalCount = Object.keys(ACHIEVEMENTS).length;

            for (const [id, achievement] of Object.entries(ACHIEVEMENTS)) {
                const unlocked = unlockedAchievements.includes(id);
                list.innerHTML += `
                    <div class="achievement-item ${unlocked ? 'unlocked' : 'locked'}">
                        <div class="achievement-item-icon">${achievement.icon}</div>
                        <div class="achievement-item-info">
                            <div class="achievement-item-name">${achievement.name}</div>
                            <div class="achievement-item-desc">${achievement.desc}</div>
                        </div>
                        ${unlocked ? '<div class="achievement-item-status">‚úì</div>' : ''}
                    </div>
                `;
            }

            // Update toggle button to show count
            document.getElementById('achievementsToggle').title = `${unlockedCount}/${totalCount} Achievements`;
        }

        // Achievement panel toggle
        document.getElementById('achievementsToggle').addEventListener('click', () => {
            document.getElementById('achievementsPanel').classList.toggle('show');
        });

        document.getElementById('achievementsClose').addEventListener('click', () => {
            document.getElementById('achievementsPanel').classList.remove('show');
        });

        // Initialize achievements list
        updateAchievementsList();

        // Color helper functions
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function lerpColor(color1, color2, ratio) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);
            const r = Math.round(r1 + (r2 - r1) * ratio);
            const g = Math.round(g1 + (g2 - g1) * ratio);
            const b = Math.round(b1 + (b2 - b1) * ratio);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Sound System
        let soundEnabled = true;
        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playSound(type) {
            if (!soundEnabled || !audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const now = audioContext.currentTime;

            switch(type) {
                case 'eat':
                    // Short pleasant blip
                    oscillator.frequency.setValueAtTime(600, now);
                    oscillator.frequency.exponentialRampToValueAtTime(900, now + 0.1);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case 'powerup':
                    // Ascending magical sound
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    oscillator.start(now);
                    oscillator.stop(now + 0.3);
                    break;

                case 'death':
                    // Descending sad sound
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.4);
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    oscillator.start(now);
                    oscillator.stop(now + 0.4);
                    break;

                case 'highscore':
                    // Victory fanfare
                    const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                    notes.forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.setValueAtTime(freq, now + i * 0.15);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, now + i * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.2);
                        osc.start(now + i * 0.15);
                        osc.stop(now + i * 0.15 + 0.2);
                    });
                    return; // Early return since we handle oscillator differently

                case 'move':
                    // Very subtle tick (optional, can be annoying)
                    break;
            }
        }

        // Settings UI
        document.querySelectorAll('[data-speed]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-speed]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSpeed = btn.dataset.speed;
            });
        });

        document.querySelectorAll('[data-size]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-size]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSize = btn.dataset.size;
            });
        });

        document.getElementById('obstaclesToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            obstaclesEnabled = this.classList.contains('active');
        });

        document.getElementById('soundToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            soundEnabled = this.classList.contains('active');
            if (soundEnabled) initAudio();
        });

        document.querySelectorAll('[data-skin]').forEach(btn => {
            btn.addEventListener('click', () => {
                const wasDifferent = currentSkin !== btn.dataset.skin;
                document.querySelectorAll('[data-skin]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSkin = btn.dataset.skin;
                // Apply skin immediately without restart
                draw();
                // Achievement for changing skin
                if (wasDifferent) checkAchievement('skin_change');
            });
        });

        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;
            });
        });

        document.getElementById('applySettings').addEventListener('click', () => {
            applySettings();
            init();
        });

        function applySettings() {
            baseSpeed = speedSettings[currentSpeed];
            gameSpeed = baseSpeed;

            const size = sizeSettings[currentSize];
            tileCount = size.tiles;
            canvas.width = size.pixels;
            canvas.height = size.pixels;
            gridSize = size.pixels / size.tiles;

            generateObstacles();
        }

        function generateObstacles() {
            obstacles = [];
            if (!obstaclesEnabled) return;

            const obstacleCount = Math.floor(tileCount * 0.8);
            const centerZone = Math.floor(tileCount / 3);

            for (let i = 0; i < obstacleCount; i++) {
                let obs;
                let attempts = 0;
                do {
                    obs = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCount)
                    };
                    attempts++;
                } while (
                    attempts < 50 &&
                    (
                        (obs.x >= centerZone && obs.x < tileCount - centerZone &&
                         obs.y >= centerZone && obs.y < tileCount - centerZone) ||
                        obstacles.some(o => o.x === obs.x && o.y === obs.y)
                    )
                );

                if (attempts < 50) {
                    obstacles.push(obs);
                }
            }
        }

        // Power-up functions
        function spawnPowerup() {
            const types = Object.keys(POWERUP_TYPES);
            const type = types[Math.floor(Math.random() * types.length)];

            let attempts = 0;
            let pos;
            do {
                pos = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                attempts++;
            } while (
                attempts < 100 &&
                (snake.some(seg => seg.x === pos.x && seg.y === pos.y) ||
                 obstacles.some(obs => obs.x === pos.x && obs.y === pos.y) ||
                 (food.x === pos.x && food.y === pos.y))
            );

            powerup = { ...pos, type };
        }

        function collectPowerup(type) {
            const powerupInfo = POWERUP_TYPES[type];
            activePowerups[type].active = true;
            activePowerups[type].endTime = Date.now() + powerupInfo.duration;

            // Apply immediate effects
            if (type === 'speed') {
                gameSpeed = Math.max(gameSpeed * 0.6, 30);
                clearInterval(gameLoop);
                gameLoop = setInterval(update, gameSpeed);
            } else if (type === 'slow') {
                gameSpeed = baseSpeed * 1.5;
                clearInterval(gameLoop);
                gameLoop = setInterval(update, gameSpeed);
            } else if (type === 'double') {
                scoreMultiplier = 2;
            }

            powerup = null;
            updatePowerupDisplay();
        }

        function updatePowerups() {
            const now = Date.now();

            for (const type of Object.keys(activePowerups)) {
                if (activePowerups[type].active && now >= activePowerups[type].endTime) {
                    activePowerups[type].active = false;

                    // Remove effects
                    if (type === 'speed' || type === 'slow') {
                        gameSpeed = baseSpeed;
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                    } else if (type === 'double') {
                        scoreMultiplier = 1;
                    }

                    updatePowerupDisplay();
                }
            }

            // Spawn new powerup
            if (!powerup && now - lastPowerupSpawn >= POWERUP_SPAWN_INTERVAL) {
                spawnPowerup();
                lastPowerupSpawn = now;
            }
        }

        function updatePowerupDisplay() {
            const now = Date.now();
            let html = '';

            for (const [type, state] of Object.entries(activePowerups)) {
                if (state.active) {
                    const remaining = Math.ceil((state.endTime - now) / 1000);
                    const info = POWERUP_TYPES[type];
                    html += `<div class="powerup-indicator ${type}">${info.name} ${remaining}s</div>`;
                }
            }

            activePowerupsEl.innerHTML = html;
        }

        // Auth functions
        window.signIn = async function() {
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Sign in error:", error);
            }
        };

        window.signOutUser = async function() {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Sign out error:", error);
            }
        };

        onAuthStateChanged(auth, async (user) => {
            currentUser = user;
            if (user) {
                authContainer.innerHTML = `
                    <div class="user-info">
                        <img class="user-avatar" src="${user.photoURL || 'https://via.placeholder.com/40'}" alt="avatar">
                        <span class="user-name">${user.displayName || 'Player'}</span>
                        <button class="auth-btn sign-out" onclick="signOutUser()">Sign Out</button>
                    </div>
                `;
                await loadPersonalBest();
            } else {
                authContainer.innerHTML = `
                    <button class="auth-btn" onclick="signIn()">
                        <svg class="google-icon" viewBox="0 0 24 24" style="width:18px;height:18px">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        Sign in with Google
                    </button>
                `;
                personalBest = parseInt(localStorage.getItem('snakeHighScore') || '0');
                highScoreEl.textContent = personalBest;
            }
            loadLeaderboard();
        });

        async function loadPersonalBest() {
            if (!currentUser) return;
            try {
                const userDoc = await getDoc(doc(db, 'scores', currentUser.uid));
                if (userDoc.exists()) {
                    personalBest = userDoc.data().score;
                    highScoreEl.textContent = personalBest;
                }
            } catch (error) {
                console.error("Error loading personal best:", error);
            }
        }

        async function saveScore(newScore) {
            if (!currentUser) {
                const localBest = parseInt(localStorage.getItem('snakeHighScore') || '0');
                if (newScore > localBest) {
                    localStorage.setItem('snakeHighScore', newScore);
                    personalBest = newScore;
                    highScoreEl.textContent = personalBest;
                    return true;
                }
                return false;
            }

            try {
                const userRef = doc(db, 'scores', currentUser.uid);
                const userDoc = await getDoc(userRef);
                const currentBest = userDoc.exists() ? userDoc.data().score : 0;

                if (newScore > currentBest) {
                    await setDoc(userRef, {
                        score: newScore,
                        displayName: currentUser.displayName || 'Anonymous',
                        photoURL: currentUser.photoURL || '',
                        updatedAt: new Date()
                    });
                    personalBest = newScore;
                    highScoreEl.textContent = personalBest;
                    loadLeaderboard();
                    return true;
                }
            } catch (error) {
                console.error("Error saving score:", error);
            }
            return false;
        }

        async function loadLeaderboard() {
            try {
                const q = query(collection(db, 'scores'), orderBy('score', 'desc'), limit(10));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    leaderboardList.innerHTML = '<li class="no-scores">No scores yet. Be the first!</li>';
                    return;
                }

                leaderboardList.innerHTML = '';
                let rank = 1;
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const isCurrentUser = currentUser && doc.id === currentUser.uid;
                    const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : 'normal';

                    leaderboardList.innerHTML += `
                        <li class="leaderboard-item ${isCurrentUser ? 'current-user' : ''}">
                            <span class="rank ${rankClass}">#${rank}</span>
                            <img class="player-avatar" src="${data.photoURL || 'https://via.placeholder.com/32'}" alt="">
                            <div class="player-info">
                                <div class="player-name">${data.displayName || 'Anonymous'}</div>
                            </div>
                            <span class="player-score">${data.score}</span>
                        </li>
                    `;
                    rank++;
                });
            } catch (error) {
                console.error("Error loading leaderboard:", error);
                leaderboardList.innerHTML = '<li class="no-scores">Error loading leaderboard</li>';
            }
        }

        // Game functions
        function init() {
            const startX = Math.floor(tileCount / 4);
            const startY = Math.floor(tileCount / 2);

            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            gameSpeed = baseSpeed;
            scoreMultiplier = 1;
            powerup = null;
            lastPowerupSpawn = Date.now();
            gameStartTime = Date.now();
            totalFoodEaten = 0;
            combo = 0;
            lastFoodTime = 0;
            document.getElementById('comboDisplay').innerHTML = '';

            // Mode achievements
            if (currentMode === 'nowalls') checkAchievement('no_walls');
            if (currentMode === 'timeattack') checkAchievement('time_attack');
            if (currentMode === 'zen') checkAchievement('zen_master');

            // Reset powerups
            for (const type of Object.keys(activePowerups)) {
                activePowerups[type] = { active: false, endTime: 0 };
            }
            activePowerupsEl.innerHTML = '';

            // Setup game mode
            const mode = GAME_MODES[currentMode];
            const modeIndicator = document.getElementById('modeIndicator');
            const timerDisplay = document.getElementById('timerDisplay');
            const timerEl = document.getElementById('timer');

            modeIndicator.innerHTML = `Mode: <span>${mode.name}</span> - ${mode.description}`;

            // Clear any existing timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // Setup timer for Time Attack
            if (mode.hasTimer) {
                timeLeft = mode.timerDuration;
                timerEl.textContent = timeLeft;
                timerDisplay.style.display = 'block';
                timerDisplay.classList.remove('urgent');

                timerInterval = setInterval(() => {
                    if (!isPaused) {
                        timeLeft--;
                        timerEl.textContent = timeLeft;

                        if (timeLeft <= 10) {
                            timerDisplay.classList.add('urgent');
                        }

                        if (timeLeft <= 0) {
                            clearInterval(timerInterval);
                            timerInterval = null;
                            gameOver();
                        }
                    }
                }, 1000);
            } else {
                timerDisplay.style.display = 'none';
            }

            scoreEl.textContent = score;
            spawnFood();
            gameOverEl.style.display = 'none';
            newRecordEl.style.display = 'none';
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);
        }

        function spawnFood() {
            let attempts = 0;
            do {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                attempts++;
            } while (
                attempts < 100 &&
                (snake.some(seg => seg.x === food.x && seg.y === food.y) ||
                 obstacles.some(obs => obs.x === food.x && obs.y === food.y))
            );

            // Pick random food type based on chance
            const roll = Math.random() * 100;
            let cumulative = 0;
            for (const [type, info] of Object.entries(FOOD_TYPES)) {
                cumulative += info.chance;
                if (roll < cumulative) {
                    food.type = type;
                    break;
                }
            }
            if (!food.type) food.type = 'apple';
        }

        function update() {
            if (isPaused) return;

            updatePowerups();
            updatePowerupDisplay();

            direction = { ...nextDirection };

            const head = {
                x: snake[0].x + direction.x,
                y: snake[0].y + direction.y
            };

            const mode = GAME_MODES[currentMode];
            const canPassWalls = activePowerups.shield.active || mode.noWalls;
            const canDie = !mode.noDeath && !activePowerups.shield.active;

            // Wall collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                if (canPassWalls) {
                    // Wrap around
                    if (head.x < 0) head.x = tileCount - 1;
                    if (head.x >= tileCount) head.x = 0;
                    if (head.y < 0) head.y = tileCount - 1;
                    if (head.y >= tileCount) head.y = 0;
                } else if (canDie) {
                    gameOver();
                    return;
                }
            }

            // Self collision
            if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
                if (canDie) {
                    gameOver();
                    return;
                } else {
                    // In zen mode, teleport head away from collision
                    head.x = (head.x + Math.floor(tileCount / 2)) % tileCount;
                    head.y = (head.y + Math.floor(tileCount / 2)) % tileCount;
                }
            }

            // Obstacle collision
            if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) {
                if (canDie) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head);

            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                const foodInfo = FOOD_TYPES[food.type];
                totalFoodEaten++;

                // Achievements for food
                checkAchievement('first_food');
                if (food.type === 'golden') {
                    checkAchievement('golden_catch');
                    goldenEatenToday++;
                    updateDailyChallengeProgress('golden', goldenEatenToday);
                }

                // Daily challenge - food count
                updateDailyChallengeProgress('food', totalFoodEaten);

                // Play appropriate sound
                if (food.type === 'rotten') {
                    playSound('death'); // Bad sound for rotten
                } else if (food.type === 'golden') {
                    playSound('powerup'); // Special sound for golden
                } else {
                    playSound('eat');
                }

                // Add points with combo multiplier (rotten food doesn't benefit from combo)
                const comboMultiplier = food.type !== 'rotten' ? addCombo() : 1;
                if (food.type === 'rotten') combo = 0; // Rotten food breaks combo
                const points = Math.floor(foodInfo.points * scoreMultiplier * comboMultiplier);
                score = Math.max(0, score + points);
                scoreEl.textContent = score;

                // Score achievements
                if (score >= 50) checkAchievement('score_50');
                if (score >= 100) checkAchievement('score_100');
                if (score >= 250) checkAchievement('score_250');
                if (score >= 500) checkAchievement('score_500');
                if (score >= 1000) checkAchievement('score_1000');

                // Daily challenge - score
                updateDailyChallengeProgress('score', score);

                // Handle growth (positive = grow, negative = shrink)
                if (foodInfo.grow > 0) {
                    // Add extra segments for growth > 1
                    for (let i = 1; i < foodInfo.grow; i++) {
                        snake.push({ ...snake[snake.length - 1] });
                    }
                } else if (foodInfo.grow < 0) {
                    // Shrink snake (but keep minimum length of 2)
                    for (let i = 0; i < Math.abs(foodInfo.grow) && snake.length > 2; i++) {
                        snake.pop();
                    }
                    snake.pop(); // Normal pop
                }

                spawnFood();

                // Length achievements
                if (snake.length >= 10) checkAchievement('length_10');
                if (snake.length >= 20) checkAchievement('length_20');
                if (snake.length >= 50) checkAchievement('length_50');

                // Daily challenge - length and combo
                updateDailyChallengeProgress('length', snake.length);
                updateDailyChallengeProgress('combo', combo);

                const minSpeed = Math.max(baseSpeed * 0.5, 30);
                if (gameSpeed > minSpeed && !activePowerups.slow.active && foodInfo.grow > 0) {
                    gameSpeed -= 2;
                    clearInterval(gameLoop);
                    gameLoop = setInterval(update, gameSpeed);
                }
            } else {
                snake.pop();
            }

            // Check powerup collision
            if (powerup && head.x === powerup.x && head.y === powerup.y) {
                playSound('powerup');
                collectPowerup(powerup.type);
                checkAchievement('powerup_collect');
            }

            // Check survive achievement (60 seconds)
            const surviveTime = (Date.now() - gameStartTime) / 1000;
            if (surviveTime >= 60) checkAchievement('survive_60');

            // Update combo display
            updateComboDisplay();

            draw();
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Obstacles
            obstacles.forEach(obs => {
                ctx.fillStyle = '#ff6600';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.roundRect(
                    obs.x * gridSize + 2,
                    obs.y * gridSize + 2,
                    gridSize - 4,
                    gridSize - 4,
                    4
                );
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Power-up
            if (powerup) {
                const pColor = POWERUP_TYPES[powerup.type].color;
                ctx.fillStyle = pColor;
                ctx.shadowColor = pColor;
                ctx.shadowBlur = 20;

                // Draw star shape
                const cx = powerup.x * gridSize + gridSize / 2;
                const cy = powerup.y * gridSize + gridSize / 2;
                const spikes = 5;
                const outerRadius = gridSize / 2 - 2;
                const innerRadius = gridSize / 4;

                ctx.beginPath();
                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI / spikes) - Math.PI / 2;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Food
            const foodInfo = FOOD_TYPES[food.type] || FOOD_TYPES.apple;
            ctx.fillStyle = foodInfo.color;
            ctx.shadowColor = foodInfo.color;
            ctx.shadowBlur = food.type === 'golden' ? 25 : 15;

            const fx = food.x * gridSize + gridSize / 2;
            const fy = food.y * gridSize + gridSize / 2;

            if (food.type === 'golden') {
                // Golden apple - sparkly diamond shape
                ctx.beginPath();
                ctx.moveTo(fx, fy - gridSize / 2 + 2);
                ctx.lineTo(fx + gridSize / 2 - 2, fy);
                ctx.lineTo(fx, fy + gridSize / 2 - 2);
                ctx.lineTo(fx - gridSize / 2 + 2, fy);
                ctx.closePath();
                ctx.fill();
            } else if (food.type === 'cherry') {
                // Cherry - two small circles
                const cherryR = gridSize / 4;
                ctx.beginPath();
                ctx.arc(fx - cherryR / 2, fy + 2, cherryR, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(fx + cherryR / 2 + 2, fy - 2, cherryR, 0, Math.PI * 2);
                ctx.fill();
                // Stem
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(fx - cherryR / 2, fy - cherryR + 2);
                ctx.quadraticCurveTo(fx, fy - gridSize / 2, fx + cherryR / 2 + 2, fy - cherryR);
                ctx.stroke();
            } else if (food.type === 'rotten') {
                // Rotten - irregular blob with X
                ctx.beginPath();
                ctx.arc(fx, fy, gridSize / 2 - 3, 0, Math.PI * 2);
                ctx.fill();
                // Draw X mark
                ctx.strokeStyle = '#2d1810';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(fx - 4, fy - 4);
                ctx.lineTo(fx + 4, fy + 4);
                ctx.moveTo(fx + 4, fy - 4);
                ctx.lineTo(fx - 4, fy + 4);
                ctx.stroke();
            } else {
                // Regular apple - circle
                ctx.beginPath();
                ctx.arc(fx, fy, gridSize / 2 - 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;

            // Snake
            const skin = SNAKE_SKINS[currentSkin];
            snake.forEach((segment, index) => {
                const alpha = 1 - (index / snake.length) * 0.5;

                // Handle shield override or skin colors
                if (activePowerups.shield.active) {
                    ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.shadowColor = '#00ffff';
                } else if (skin.primary === 'rainbow') {
                    // Rainbow effect - each segment is different color
                    const hue = ((index * 30) + Date.now() / 20) % 360;
                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                } else {
                    // Gradient between primary and secondary based on position
                    const colorRatio = index / Math.max(snake.length - 1, 1);
                    ctx.fillStyle = index === 0
                        ? hexToRgba(skin.primary, alpha)
                        : hexToRgba(lerpColor(skin.primary, skin.secondary, colorRatio), alpha);
                    ctx.shadowColor = skin.glow;
                }
                ctx.shadowBlur = index === 0 ? 10 : 5;

                ctx.beginPath();
                ctx.roundRect(
                    segment.x * gridSize + 1,
                    segment.y * gridSize + 1,
                    gridSize - 2,
                    gridSize - 2,
                    5
                );
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Eyes
            if (snake.length > 0) {
                const head = snake[0];
                ctx.fillStyle = activePowerups.shield.active ? '#1a1a2e' : skin.eye;

                let eye1X, eye1Y, eye2X, eye2Y;
                const eyeOffset = gridSize * 0.3;
                const eyeSize = gridSize * 0.15;

                if (direction.x === 1) {
                    eye1X = head.x * gridSize + gridSize - eyeOffset;
                    eye1Y = head.y * gridSize + eyeOffset;
                    eye2X = head.x * gridSize + gridSize - eyeOffset;
                    eye2Y = head.y * gridSize + gridSize - eyeOffset;
                } else if (direction.x === -1) {
                    eye1X = head.x * gridSize + eyeOffset;
                    eye1Y = head.y * gridSize + eyeOffset;
                    eye2X = head.x * gridSize + eyeOffset;
                    eye2Y = head.y * gridSize + gridSize - eyeOffset;
                } else if (direction.y === -1) {
                    eye1X = head.x * gridSize + eyeOffset;
                    eye1Y = head.y * gridSize + eyeOffset;
                    eye2X = head.x * gridSize + gridSize - eyeOffset;
                    eye2Y = head.y * gridSize + eyeOffset;
                } else {
                    eye1X = head.x * gridSize + eyeOffset;
                    eye1Y = head.y * gridSize + gridSize - eyeOffset;
                    eye2X = head.x * gridSize + gridSize - eyeOffset;
                    eye2Y = head.y * gridSize + gridSize - eyeOffset;
                }

                ctx.beginPath();
                ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Pause overlay
            if (isPaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ff88';
                ctx.font = `bold ${gridSize * 1.5}px Segoe UI`;
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        function screenShake() {
            const wrapper = document.querySelector('.canvas-wrapper');
            wrapper.classList.add('shake');
            canvas.classList.add('flash');

            setTimeout(() => {
                wrapper.classList.remove('shake');
                canvas.classList.remove('flash');
            }, 500);
        }

        async function gameOver() {
            clearInterval(gameLoop);
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            playSound('death');
            screenShake();

            // Small delay before showing game over for dramatic effect
            await new Promise(resolve => setTimeout(resolve, 300));

            finalScoreEl.textContent = score;
            const isNewRecord = await saveScore(score);

            if (isNewRecord && score > 0) {
                newRecordEl.style.display = 'block';
                playSound('highscore');
            } else {
                newRecordEl.style.display = 'none';
            }

            gameOverEl.style.display = 'block';
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            initAudio(); // Initialize audio on first interaction

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
                    break;
                case ' ':
                    isPaused = !isPaused;
                    draw();
                    break;
            }
        });

        document.getElementById('upBtn').addEventListener('click', () => {
            if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
        });
        document.getElementById('downBtn').addEventListener('click', () => {
            if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
        });
        document.getElementById('leftBtn').addEventListener('click', () => {
            if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
        });
        document.getElementById('rightBtn').addEventListener('click', () => {
            if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
        });

        restartBtn.addEventListener('click', init);

        // Start
        applySettings();
        init();
    </script>
</body>
</html>
